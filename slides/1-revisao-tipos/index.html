<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="author" content="Igor Machado Coelho">
  <title>Estruturas de Dados I</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="./reveal.js/dist/reset.css">
  <link rel="stylesheet" href="./reveal.js/dist/reveal.css">
  <style>
    .reveal .sourceCode {  /* see #7635 */
      overflow: visible;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    /* CSS for syntax highlighting */
    html { -webkit-text-size-adjust: 100%; }
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="./reveal.js/dist/theme/beige.css" id="theme">
  <link rel="stylesheet" href="katex.min.css"/>
  <link rel="stylesheet" type="text/css" href="general.css">
  <link rel="stylesheet" type="text/css" href="reveal-beamer.css">
</head>
<body>
  <div class="reveal">
    <div class="slides">

<section id="title-slide">
  <h1 class="title">Estruturas de Dados I</h1>
  <p class="subtitle">Revisão de Tipos e Módulos</p>
  <p class="author">Igor Machado Coelho</p>
  <p class="date">13/09/2020 - 26/03/2025</p>
</section>

<section>
<section id="revisão-de-tipos-e-módulos"
class="title-slide slide level1">
<h1>Revisão de Tipos e Módulos</h1>

</section>
<section id="pré-requisitos" class="slide level2">
<h2>Pré-Requisitos</h2>
<p>São requisitos para essa aula o conhecimento de:</p>
<ul>
<li>Introdução/Fundamentos de Programação (em alguma linguagem de
programação)</li>
<li>Interesse em aprender C/C++</li>
<li>Familiaridade com uso e instalação de compiladores/IDEs ou uso de
ferramentas de programação online</li>
</ul>
</section>
<section id="ambiente-de-programação" class="slide level2">
<h2>Ambiente de Programação</h2>
<p>Exemplos serão dados com base no sistema GNU/Linux e compiladores
GCC, mas existem ferramentas equivalentes para Windows e demais sistemas
operacionais. A IDE Visual Studio Code suporta a linguagem C++ tanto
para Linux (nativamente) quanto para Windows (com a instalação do
compilador MinGW).</p>
<p>Também é possível praticar diretamente em um navegador web com
plataformas online: <a
href="https://www.onlinegdb.com/online_c++_compiler">onlinegdb.com/online_c++_compiler</a>.
Neste caso, o aluno pode escolher o compilador de C ou da linguagem C++
(considerando padrões C23 e C++23).</p>
</section></section>
<section>
<section id="parte-1-tipos-primitivos-compostos-e-genéricos-em-cc"
class="title-slide slide level1">
<h1>Parte 1: Tipos Primitivos, Compostos e Genéricos em C/C++</h1>

</section>
<section id="conceitos-de-cc" class="slide level2">
<h2>Conceitos de C/C++</h2>
<p>Compreender a lógica da programação é a habilidade mais importante
para um programador! Com ela, você pode facilmente trocar de linguagem
de programação, conhecendo apenas alguns comandos básicos.</p>
<p>O primeiro conceito a ser revisado é de variável. Uma variável
consiste de um identificador válido (mesmo para outras linguagens
populares como Python) e armazena algum tipo de dado da memória do
computador.</p>
<p>A linguagem C/C++ é <strong>fortemente tipada</strong>, portando o
programador deve dizer explicitamente qual o tipo de dado deseja
armazenar em cada variável.</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode .cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span>   x <span class="op">=</span> <span class="dv">5</span><span class="op">;</span>    <span class="co">// armazena o inteiro 5 na variável x</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span>  y <span class="op">=</span> <span class="ch">&#39;A&#39;</span><span class="op">;</span>  <span class="co">// armazena o caractere &#39;A&#39; na variável y</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> z <span class="op">=</span> <span class="fl">3.7</span> <span class="op">;</span> <span class="co">// armazena o real 3.7 na variável z</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> v <span class="op">=</span> <span class="kw">true</span><span class="op">;</span>  <span class="co">// armazena o booleano true na variável v</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> b <span class="op">=</span> <span class="ch">&#39;B&#39;</span><span class="op">;</span>     <span class="co">// dedução de tipo com &#39;auto&#39;... qual tipo?</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> s <span class="op">=</span> <span class="st">&quot;abcd&quot;</span><span class="op">;</span>  <span class="co">// cadeia de caracteres, ainda veremos tipo</span></span></code></pre></div>
<p><strong>Responda:</strong> Qual o tipo acima de b? (C++23 e C23)</p>
</section>
<section id="tipos-de-variáveis" class="slide level2">
<h2>Tipos de Variáveis</h2>
<p><strong>Pergunta/Resposta</strong>: Cuidado com tipos. Quais são os
valores armazenados nas variáveis abaixo (C++23 e C23)?</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode cpp listing"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span>    x1 <span class="op">=</span> <span class="dv">5</span><span class="op">;</span>        <span class="co">// =&gt; 5</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span>    x2 <span class="op">=</span> x1 <span class="op">+</span> <span class="dv">10</span><span class="op">;</span>  <span class="co">// =&gt; 15</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span>    x3 <span class="op">=</span> x2 <span class="op">/</span> <span class="dv">2</span><span class="op">;</span>   <span class="co">// =&gt; 7</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span>  x4 <span class="op">=</span> x2 <span class="op">/</span> <span class="dv">2</span><span class="op">;</span>   <span class="co">// =&gt; 7.0</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span>  x5 <span class="op">=</span> x2 <span class="op">/</span> <span class="fl">2.0</span><span class="op">;</span> <span class="co">// =&gt; 7.5</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span>   x6 <span class="op">=</span> <span class="dv">15</span><span class="op">;</span>       <span class="co">// =&gt; 15 </span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span>   x7 <span class="op">=</span> x2 <span class="op">/</span> <span class="dv">2</span><span class="op">;</span>   <span class="co">// =&gt; 7</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span>   x8 <span class="op">=</span> x2 <span class="op">/</span> <span class="fl">2.0</span><span class="op">;</span> <span class="co">// =&gt; 7.5</span></span></code></pre></div>
<p>Verifiquem essas operações de variáveis, escrevendo na saída padrão
(tela do computador).</p>
</section>
<section id="conceitos-de-cc-tipos-definidos" class="slide level2">
<h2>Conceitos de C/C++ (tipos definidos)</h2>
<p>Tipos primitivos em C/C++ tem um tamanho definido, então é uma boa
prática utilizar tamanhos fixos.</p>
<p>Dê preferência a inicialização direta com chaves <code>{ }</code>, ao
invés de indireta por atribuição (<code>operator=</code>).</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode .cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int64_t</span> x1 <span class="op">=</span> <span class="dv">10</span><span class="op">;</span>  <span class="co">// long (ou long long)</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int32_t</span> x2 <span class="op">=</span> <span class="dv">20</span><span class="op">;</span>  <span class="co">// int</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int16_t</span> x3 <span class="op">=</span> <span class="dv">30</span><span class="op">;</span>  <span class="co">// short</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int8_t</span>  x4 <span class="op">=</span> <span class="dv">40</span><span class="op">;</span>  <span class="co">// signed char</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">uint8_t</span> x5 <span class="op">=</span> <span class="dv">50</span><span class="op">;</span>  <span class="co">// unsigned char</span></span></code></pre></div>
</section>
<section id="impressão-de-saída-padrão" class="slide level2">
<h2>Impressão de Saída Padrão</h2>
<p>Em C, tipicamente é utilizado o comando <code>printf</code>, mas
devido a inúmeras falhas de segurança, é recomendado o uso de uma
alternativa mais segura. Assim, em C++, para imprimir na saída padrão
utilizaremos o comando <code>std::print</code>.</p>
<p>O C++23 traz oficialmente <code>std::print</code> e
<code>std::println</code> como parte do módulo de biblioteca padrão
<code>std</code>. Para utilizá-lo, basta fazer
<code>import std;</code>.</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode .cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> std<span class="op">;</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> main<span class="op">()</span> <span class="op">-&gt;</span> <span class="dt">int</span> <span class="op">{</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>  <span class="bu">std::</span>println<span class="op">(</span><span class="st">&quot;Olá Mundo!&quot;</span><span class="op">);</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="co">// https://godbolt.org/z/dvc5hdv3n</span></span></code></pre></div>
<p><strong>Pergunta:</strong> Qual o tipo de retorno da função
<code>main</code>?</p>
</section>
<section id="impressão-de-saída-padrão-1" class="slide level2">
<h2>Impressão de Saída Padrão</h2>
<p>Para imprimir na saída padrão utilizaremos o comando
<code>std::print</code>, e é possível evitar o prefixo
<code>std::</code> com um <code>using namespace std;</code>.</p>
<p><strong>Pergunta:</strong> como podemos misturar um texto (também
chamado de cadeia de caracteres ou string) com o conteúdo de
variáveis?</p>
<div class="fragment">
<p><strong>Resposta:</strong> através do padrão de substituição
<code>{}</code>.</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode .cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> std<span class="op">;</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> main<span class="op">()</span> <span class="op">-&gt;</span> <span class="dt">int</span> <span class="op">{</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int32_t</span> x1 <span class="op">=</span> <span class="dv">7</span><span class="op">;</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>  println<span class="op">(</span><span class="st">&quot;x1 é </span><span class="sc">{}</span><span class="st">&quot;</span><span class="op">,</span> x1<span class="op">);</span>  <span class="co">// x1 é 7</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">float</span> x6 <span class="op">=</span> x1 <span class="op">/</span> <span class="fl">2.0</span><span class="op">;</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>  println<span class="op">(</span><span class="st">&quot;metade de </span><span class="sc">{}</span><span class="st"> é </span><span class="sc">{}</span><span class="st">&quot;</span><span class="op">,</span> x1<span class="op">,</span> x6<span class="op">);</span>  <span class="co">// metade de 7 é 3.5</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">char</span> b <span class="op">=</span> <span class="ch">&#39;L&#39;</span><span class="op">;</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>  println<span class="op">(</span><span class="st">&quot;isto é uma </span><span class="sc">{}</span><span class="st">etra&quot;</span><span class="op">,</span> b<span class="op">);</span>  <span class="co">// isto é uma Letra</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>  print<span class="op">(</span><span class="st">&quot;Olá mundo! </span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span>  <span class="co">// Olá mundo! (quebra de linha)</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ====================================================</span></span></code></pre></div>
</div>
</section>
<section id="condicionais" class="slide level2">
<h2>Condicionais</h2>
<p><strong>Problema:</strong> dados <code>x</code> e <code>y</code>,
imprima o maior valor.</p>
<div class="fragment">
<p>Condicionais podem ser feitos através dos comandos if ou if else.</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode .cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> x <span class="op">=</span> <span class="dv">15</span><span class="op">;</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> y <span class="op">=</span> <span class="dv">12</span><span class="op">;</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>x <span class="op">&gt;</span> y<span class="op">)</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>   println<span class="op">(</span><span class="st">&quot;x é maior que y&quot;</span><span class="op">);</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>   println<span class="op">(</span><span class="st">&quot;x menor ou igual a y&quot;</span><span class="op">);</span></span></code></pre></div>
</div>
</section>
<section id="laços-de-repetição" class="slide level2">
<h2>Laços de Repetição</h2>
<p>Laços de repetição podem ser feitos através de comandos while ou for.
Um comando for é dividido em três partes: inicialização, condição de
continuação e incremento.</p>
<div class="columns">
<div class="column" style="width:55%;">
<div class="sourceCode" id="cb7"><pre
class="sourceCode .cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> i<span class="op">=</span><span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">10</span> <span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>   println<span class="op">(</span><span class="st">&quot;i : </span><span class="sc">{}</span><span class="st">&quot;</span> <span class="op">,</span> i<span class="op">);</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div><div class="column" style="width:45%;">
<div class="sourceCode" id="cb8"><pre
class="sourceCode .cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> j<span class="op">=</span><span class="dv">0</span><span class="op">;</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="op">(</span>j <span class="op">&lt;</span> <span class="dv">10</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>   println<span class="op">(</span><span class="st">&quot;j : </span><span class="sc">{}</span><span class="st">&quot;</span><span class="op">,</span> j<span class="op">);</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>   j<span class="op">++;</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<p><strong>Pergunta:</strong> O que é impresso em ambos laços?</p>
</section>
<section id="tipos-compostos" class="slide level2">
<h2>Tipos Compostos</h2>
<p>Além dos tipos primitivos apresentados anteriormente (int, float,
char, …), a linguagem C/C++ nos permite criar tipos compostos.</p>
<p><strong>Tarefa:</strong> estude demais tipos primitivos como double e
long long, bem como os modificadores unsigned, signed, short e long.</p>
<p>Os tipos compostos podem ser vetores (arrays) ou agregados (structs,
…).</p>
<div class="fragment">
<div class="sourceCode" id="cb9"><pre
class="sourceCode .cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int32_t</span> v<span class="op">[</span><span class="dv">8</span><span class="op">];</span> <span class="co">// cria um vetor com 8 inteiros</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>v<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">3</span><span class="op">;</span>     <span class="co">// atribui o valor 3 à primeira posição</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>v<span class="op">[</span><span class="dv">7</span><span class="op">]</span> <span class="op">=</span> <span class="dv">5</span><span class="op">;</span>     <span class="co">// atribui o valor 5 à última posição</span></span></code></pre></div>
<p>Exemplo de um vetor <code>v</code>, de 0 a 7, da esquerda para
direita:</p>
<pre><code>          v: | 3 |   |   |   |   |   |   | 5 |
               0   1   2   3   4   5   6   7</code></pre>
</div>
</section>
<section id="controle-de-fluxo-com-break-e-continue"
class="slide level2">
<h2>Controle de fluxo com <code>break</code> e
<code>continue</code></h2>
<p>Controles de fluxo em laços de repetição podem ser efetuados com
<code>break</code> e <code>continue</code>. O <code>break</code>
finaliza a execução do laço e o <code>continue</code> recomeça o
laço.</p>
<p><strong>Problema</strong>: Dado um vetor B, encontre o
primeiro/último valor negativo, ou imprima -1 caso não exista.</p>
<div class="columns">
<div class="column" style="width:55%;">
<div class="sourceCode" id="cb11"><pre
class="sourceCode .cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> B<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">4</span><span class="op">,</span> <span class="op">-</span><span class="dv">3</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="op">-</span><span class="dv">7</span><span class="op">,</span> <span class="dv">8</span><span class="op">};</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> z <span class="op">=</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> i<span class="op">=</span><span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">5</span><span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>   <span class="cf">if</span> <span class="op">(</span>B<span class="op">[</span>i<span class="op">]</span> <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>      z <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>      <span class="cf">break</span><span class="op">;</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>   <span class="op">}</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>println<span class="op">(</span><span class="st">&quot;z=</span><span class="sc">{}</span><span class="st">&quot;</span><span class="op">,</span> z<span class="op">);</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a><span class="co">// z==1</span></span></code></pre></div>
</div><div class="column" style="width:45%;">
<div class="sourceCode" id="cb12"><pre
class="sourceCode .cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> B<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">4</span><span class="op">,</span> <span class="op">-</span><span class="dv">3</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="op">-</span><span class="dv">7</span><span class="op">,</span> <span class="dv">8</span><span class="op">};</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> z <span class="op">=</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> i<span class="op">=</span><span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">5</span><span class="op">;</span> i<span class="op">++){</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>   <span class="cf">if</span> <span class="op">(</span>B<span class="op">[</span>i<span class="op">]</span> <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>      <span class="cf">continue</span><span class="op">;</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>   z <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>println<span class="op">(</span><span class="st">&quot;z=</span><span class="sc">{}</span><span class="st">&quot;</span><span class="op">,</span> z<span class="op">);</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a><span class="co">// z==3</span></span></code></pre></div>
</div>
</div>
</section>
<section id="saltos-incondicionais-com-goto" class="slide level2">
<h2>Saltos incondicionais com <code>goto</code></h2>
<p>Saltos incondicionais no código podem ser feitos com
<code>goto label;</code> e <code>label:</code>. Uma aplicação usual é a
“quebra múltipla” de laços de repetição. Evite ao máximo o uso de
<code>goto</code> e, sempre que for possível, prefira alternativas
estruturadas como <code>for</code>, <code>while</code>, <code>if</code>,
<code>else</code>, <code>break</code>, etc.</p>
<p>Contabilize quantos prints são executados (variável
<code>z</code>):</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode .cpp"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> z <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">10</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>i <span class="op">&lt;</span> <span class="dv">5</span><span class="op">)</span> <span class="cf">continue</span><span class="op">;</span> <span class="dt">int</span> j <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>j <span class="op">&lt;</span> <span class="dv">10</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> <span class="op">(</span>i <span class="op">&gt;</span> <span class="dv">6</span><span class="op">)</span> <span class="cf">goto</span> fim<span class="op">;</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>      println<span class="op">(</span><span class="st">&quot;z=</span><span class="sc">{}</span><span class="st"> i=</span><span class="sc">{}</span><span class="st"> j=</span><span class="sc">{}</span><span class="st">&quot;</span><span class="op">,</span> z<span class="op">,</span> i<span class="op">,</span> j<span class="op">);</span> z<span class="op">++;</span> j<span class="op">++;</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>fim<span class="op">:</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>  println<span class="op">(</span><span class="st">&quot;final z=</span><span class="sc">{}</span><span class="st">&quot;</span><span class="op">,</span> z<span class="op">);</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>  <span class="co">// z==9: i=5 j=5..9 [5 passos]; i=6 j=6..9 [4 passos]</span></span></code></pre></div>
</section>
<section id="tipos-agregados-i" class="slide level2">
<h2>Tipos Agregados I</h2>
<p>Comparação C/C++: lembre-se de usar <strong>struct</strong> ou
<strong>class public:</strong>, caso contrário não será reconhecido como
um <em>tipo agregado</em>, mas sim um <em>objeto</em>, que funciona de
forma completamente diferente na linguagem C++.</p>
<div class="columns">
<div class="column" style="width:55%;">
<div class="sourceCode" id="cb14"><pre
class="sourceCode .c"><code class="sourceCode c"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Em C (tipo agregado P)</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> P</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int32_t</span> x<span class="op">;</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> y<span class="op">;</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a><span class="co">// declara variável tipo P</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> P p1<span class="op">;</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a><span class="co">// designated initializers</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> P p2 <span class="op">=</span> <span class="op">{.</span>x<span class="op">=</span><span class="dv">10</span><span class="op">,</span> <span class="op">.</span>y<span class="op">=</span><span class="ch">&#39;Y&#39;</span><span class="op">};</span></span></code></pre></div>
</div><div class="column" style="width:45%;">
<div class="sourceCode" id="cb15"><pre
class="sourceCode .cpp"><code class="sourceCode cpp"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Em C++ (tipo agregado P)</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> P</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int32_t</span> x<span class="op">;</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> y<span class="op">;</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a><span class="co">// declara variável tipo P</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>P p1<span class="op">;</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a><span class="co">// designated initializers</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> p2 <span class="op">=</span> P<span class="op">{.</span>x<span class="op">=</span><span class="dv">10</span><span class="op">,</span> <span class="op">.</span>y<span class="op">=</span><span class="ch">&#39;Y&#39;</span><span class="op">};</span></span></code></pre></div>
</div>
</div>
</section>
<section id="tipos-agregados-ii" class="slide level2">
<h2>Tipos Agregados II</h2>
<p>Retomamos o exemplo da estrutura P anterior e nos perguntamos, como
acessar as variáveis internas do agregado P?</p>
<p>Assim como na inicialização designada, podemos utilizar o operador
ponto (.) para acessar campos do agregado. Exemplo:</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode .cpp"><code class="sourceCode cpp"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> p1 <span class="op">=</span> P<span class="op">{.</span>y <span class="op">=</span> <span class="ch">&#39;A&#39;</span><span class="op">};</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>p1<span class="op">.</span>x <span class="op">=</span> <span class="dv">20</span><span class="op">;</span>             <span class="co">// atribui 20 à variável x de p1</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>p1<span class="op">.</span>x <span class="op">=</span> p1<span class="op">.</span>x <span class="op">+</span> <span class="dv">1</span><span class="op">;</span>       <span class="co">// incrementa a variável x de p1</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>println<span class="op">(</span><span class="st">&quot;</span><span class="sc">{}</span><span class="st"> </span><span class="sc">{}</span><span class="st">&quot;</span><span class="op">,</span> p1<span class="op">.</span>x<span class="op">,</span> p1<span class="op">.</span>y<span class="op">);</span>  <span class="co">// imprime &#39;21 A&#39;</span></span></code></pre></div>
<p>Exemplo de estrutura <code>p1</code>, com p1.x e p1.y, da esquerda
para direita:</p>
<pre><code>             p1:  |      21       | &#39;A&#39; |
                        p1.x        p1.y</code></pre>
<p><strong>Importante:</strong> veremos à frente que o (.) também pode
acessar <em>métodos internos</em> do tipo agregado.</p>
</section>
<section id="espaço-de-memória" class="slide level2">
<h2>Espaço de Memória</h2>
<p>Todas variáveis de um programa ocupam determinado espaço na memória
principal do computador. <strong>Assumiremos</strong> que o tipo int (ou
float) ocupa 4 bytes, enquanto um char ocupa apenas 1 byte.</p>
<p>No caso de vetores, o espaço ocupado na memória é multiplicado pelo
número de elementos. Vamos calcular o espaço das variáveis:</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode .cpp"><code class="sourceCode cpp"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int32_t</span> v<span class="op">[</span><span class="dv">256</span><span class="op">];</span> <span class="co">// = 1024 bytes = 1 kibibyte = 1 KiB</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> x<span class="op">[</span><span class="dv">1000</span><span class="op">];</span>   <span class="co">// = 1000 bytes = 1 kilobyte = 1 kB</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="dt">float</span> y<span class="op">[</span><span class="dv">5</span><span class="op">];</span>     <span class="co">// = 20 bytes</span></span></code></pre></div>
<p>Já nos agregados, assumimos o espaço ocupado como a soma de suas
variáveis internas (embora na prática o tamanho possa ser ligeiramente
superior, devido a alinhamentos de memória).</p>
</section>
<section id="tipos-genéricos" class="slide level2">
<h2>Tipos Genéricos</h2>
<p>C++ permite a definição de tipos genéricos, ou seja, tipos que
permitem que algum <em>outro tipo</em> seja passado como parâmetro.</p>
<p>Consideremos o agregado P que carrega um int e um char… como
transformá-lo em um agregado genérico em relação à variável x?</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode .cpp"><code class="sourceCode cpp"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> G</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>   T x<span class="op">;</span>   <span class="co">// qual o tipo da variável x?</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>   <span class="dt">char</span> y<span class="op">;</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a><span class="co">// declara o agregado genérico G com tipo T=float ou T=char</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>G<span class="op">&lt;</span><span class="dt">float</span><span class="op">&gt;</span> g1 <span class="op">=</span> <span class="op">{.</span>x <span class="op">=</span> <span class="fl">3.14</span><span class="op">,</span> <span class="op">.</span>y  <span class="op">=</span> <span class="ch">&#39;Y&#39;</span><span class="op">};</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>G<span class="op">&lt;</span><span class="dt">char</span><span class="op">&gt;</span>  g2 <span class="op">=</span> <span class="op">{.</span>x <span class="op">=</span> <span class="ch">&#39;A&#39;</span><span class="op">,</span>  <span class="op">.</span>y  <span class="op">=</span> <span class="ch">&#39;Y&#39;</span><span class="op">};</span></span></code></pre></div>
<p><strong>Pergunta:</strong> Quanto espaço (em bytes) cada variável
dessa ocupa?</p>
</section>
<section id="valores-constantes-e-casts" class="slide level2">
<h2>Valores constantes e casts</h2>
<p>Em C/C+, podemos definir um valor como constante, através da palavra
<code>const</code>. Uma mudança de tipos pode ser feita com <em>type
cast</em>. Em C++, utilize <code>static_cast&lt;tipo&gt;</code> ao invés
do padrão C de cast.</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode .cpp"><code class="sourceCode cpp"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">int</span> x <span class="op">=</span> <span class="dv">10</span><span class="op">;</span>                     <span class="co">// 10</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> y1 <span class="op">=</span> x <span class="op">/</span> <span class="op">-</span><span class="dv">2</span><span class="op">;</span>                      <span class="co">// 0</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> y2 <span class="op">=</span> <span class="op">(</span><span class="dt">double</span><span class="op">)</span>x <span class="op">/</span> <span class="op">-</span><span class="dv">2</span><span class="op">;</span>              <span class="co">// -5</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> y3 <span class="op">=</span> <span class="kw">static_cast</span><span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;(</span>x<span class="op">)</span> <span class="op">/</span> <span class="op">-</span><span class="dv">2</span><span class="op">;</span> <span class="co">// -5 (C++)</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">unsigned</span> <span class="dt">int</span> z1 <span class="op">=</span> x<span class="op">;</span>               <span class="co">// 10</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a><span class="co">// z1 = 20;                              // ERRO</span></span></code></pre></div>
<p>O <code>const</code> pode ser removido através de um
<code>const_cast</code>, sendo inseguro.</p>
<p>Em C23 e C++23 existe o <code>constexpr</code>, que diferentemente do
<code>const</code>, nunca pode ser removido ou redefinido
(diferentemente de macros), pois é resolvido em tempo de compilação.</p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode .cpp"><code class="sourceCode cpp"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#define k1 </span><span class="dv">10</span><span class="pp">          </span><span class="co">// inseguro e permite redefinição</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="dt">int</span> k2 <span class="op">=</span> <span class="dv">10</span><span class="op">;</span> <span class="co">// seguro, impossível redefinir</span></span></code></pre></div>
</section>
<section id="tipo-stdstring-e-stdstring_view-na-stl"
class="slide level2">
<h2>Tipo <code>std::string</code> e <code>std::string_view</code> na
STL</h2>
<p>O tipo <code>std::string</code> representa cadeias de caracteres,
chamadas de <em>strings</em>. Ela substitui a necessidade de
<code>char*</code>, <code>char[]</code> ou <code>const char*</code> em
C.</p>
<p>Caso precise de uma “vista” leve de uma string, como um substring,
utilize <code>std::string_view</code> (evita a cópia completa do
<code>string</code>).</p>
<div class="sourceCode" id="cb22"><pre
class="sourceCode .cpp"><code class="sourceCode cpp"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>string s1 <span class="op">=</span> <span class="st">&quot;abcd&quot;</span><span class="op">;</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>string s2 <span class="op">=</span> <span class="st">&quot;ef&quot;</span><span class="op">;</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>println<span class="op">(</span><span class="st">&quot;tamanho1=</span><span class="sc">{}</span><span class="st"> tamanho2=</span><span class="sc">{}</span><span class="st">&quot;</span><span class="op">,</span> s1<span class="op">.</span>length<span class="op">(),</span> s2<span class="op">.</span>length<span class="op">());</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a><span class="co">// tamanho1=4 tamanho2=2</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>s1 <span class="op">=</span> s1 <span class="op">+</span> s2<span class="op">;</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>string_view sv <span class="op">=</span> s1<span class="op">;</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>string_view sub <span class="op">=</span> sv<span class="op">.</span>substr<span class="op">(</span><span class="dv">3</span><span class="op">,</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>println<span class="op">(</span><span class="st">&quot;s1=</span><span class="sc">{}</span><span class="st"> s2=</span><span class="sc">{}</span><span class="st"> sv=</span><span class="sc">{}</span><span class="st"> sub=</span><span class="sc">{}</span><span class="st">&quot;</span><span class="op">,</span> s1<span class="op">,</span> s2<span class="op">,</span> sv<span class="op">,</span> sub<span class="op">);</span></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a><span class="co">// s1=abcdef s2=ef sv=abcdef sub=de</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">char</span><span class="op">*</span> cs <span class="op">=</span> s1<span class="op">.</span>c_str<span class="op">();</span></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>println<span class="op">(</span><span class="st">&quot;s1=</span><span class="sc">{}</span><span class="st"> cs=</span><span class="sc">{}</span><span class="st">&quot;</span><span class="op">,</span> s1<span class="op">,</span> cs<span class="op">);</span></span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a><span class="co">// s1=abcdef cs=abcdef</span></span></code></pre></div>
</section>
<section id="tipo-stdvector-na-stl" class="slide level2">
<h2>Tipo <code>std::vector</code> na STL</h2>
<p>A popular estrutura <code>std::vector&lt;tipo&gt;</code> permite
representar vetores com tamanho variável (através do método
<code>push_back</code>). Exemplo:</p>
<div class="sourceCode" id="cb23"><pre
class="sourceCode .cpp"><code class="sourceCode cpp"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> v1<span class="op">[</span><span class="dv">10</span><span class="op">];</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> v2<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">};</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> k1<span class="op">{};</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> k2 <span class="op">=</span> <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">};</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>k2<span class="op">.</span>push_back<span class="op">(</span><span class="dv">999</span><span class="op">);</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a><span class="co">//</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>print<span class="op">(</span><span class="st">&quot;v[0]=</span><span class="sc">{}</span><span class="st"> v[3]=</span><span class="sc">{}</span><span class="st"> tam=</span><span class="sc">{}\n</span><span class="st">&quot;</span><span class="op">,</span> v2<span class="op">[</span><span class="dv">0</span><span class="op">],</span> v2<span class="op">[</span><span class="dv">3</span><span class="op">],</span> </span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>      <span class="kw">sizeof</span><span class="op">(</span>v2<span class="op">)</span> <span class="op">/</span> <span class="kw">sizeof</span><span class="op">(</span>v2<span class="op">[</span><span class="dv">0</span><span class="op">]));</span></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a><span class="co">// v[0]=1 v[3]=4 tam=4</span></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a>print<span class="op">(</span><span class="st">&quot;k[0]=</span><span class="sc">{}</span><span class="st"> k[4]=</span><span class="sc">{}</span><span class="st"> tam=</span><span class="sc">{}\n</span><span class="st">&quot;</span><span class="op">,</span> k2<span class="op">[</span><span class="dv">0</span><span class="op">],</span> k2<span class="op">[</span><span class="dv">4</span><span class="op">],</span> k2<span class="op">.</span>size<span class="op">());</span></span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a><span class="co">// k[0]=1 k[4]=999 tam=5</span></span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a>print<span class="op">(</span><span class="st">&quot;</span><span class="sc">{}\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="bu">std::</span>is_aggregate<span class="op">&lt;</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;::</span>value<span class="op">);</span></span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true" tabindex="-1"></a><span class="co">// false</span></span></code></pre></div>
</section>
<section id="tipo-stdarray-na-stl" class="slide level2">
<h2>Tipo <code>std::array</code> na STL</h2>
<p>Assim como vetores nativos, exemplo <code>int[]</code>, o agregado
<code>std::array&lt;tipo, tamanho&gt;</code> permite representar vetores
de tamanho fixo. Exemplo:</p>
<div class="sourceCode" id="cb24"><pre
class="sourceCode .cpp"><code class="sourceCode cpp"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> v1<span class="op">[</span><span class="dv">10</span><span class="op">];</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> v2<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">};</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>array<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dv">10</span><span class="op">&gt;</span> a1<span class="op">{};</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>array<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dv">4</span><span class="op">&gt;</span> a2 <span class="op">=</span> <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">};</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>print<span class="op">(</span><span class="st">&quot;v[0]=</span><span class="sc">{}</span><span class="st"> v[3]=</span><span class="sc">{}</span><span class="st"> tam=</span><span class="sc">{}\n</span><span class="st">&quot;</span><span class="op">,</span> v2<span class="op">[</span><span class="dv">0</span><span class="op">],</span> v2<span class="op">[</span><span class="dv">3</span><span class="op">],</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>      <span class="kw">sizeof</span><span class="op">(</span>v2<span class="op">)</span> <span class="op">/</span> <span class="kw">sizeof</span><span class="op">(</span>v2<span class="op">[</span><span class="dv">0</span><span class="op">]));</span></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a><span class="co">// v[0]=1 v[3]=4 tam=4</span></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>print<span class="op">(</span><span class="st">&quot;a[0]=</span><span class="sc">{}</span><span class="st"> a[3]=</span><span class="sc">{}</span><span class="st"> tam=</span><span class="sc">{}\n</span><span class="st">&quot;</span><span class="op">,</span> a2<span class="op">[</span><span class="dv">0</span><span class="op">],</span> a2<span class="op">[</span><span class="dv">3</span><span class="op">],</span> a2<span class="op">.</span>size<span class="op">());</span></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a><span class="co">// a[0]=1 a[3]=4 tam=4</span></span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>print<span class="op">(</span><span class="st">&quot;</span><span class="sc">{}</span><span class="st"> </span><span class="sc">{}</span><span class="st"> </span><span class="sc">{}\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="bu">std::</span>is_aggregate<span class="op">&lt;</span><span class="dt">int</span><span class="op">*&gt;::</span>value<span class="op">,</span></span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a>      <span class="bu">std::</span>is_aggregate<span class="op">&lt;</span><span class="dt">int</span><span class="op">[]&gt;::</span>value<span class="op">,</span></span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a>      <span class="bu">std::</span>is_aggregate<span class="op">&lt;</span><span class="bu">std::</span>array<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dv">4</span><span class="op">&gt;&gt;::</span>value<span class="op">);</span></span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a><span class="co">// false true true</span></span></code></pre></div>
</section>
<section id="resumo-até-agora" class="slide level2">
<h2>Resumo até agora</h2>
<p>Até agora, verificamos as seguinte estruturas:</p>
<ul>
<li>tipos primitivos (C)</li>
<li>tipo automático com <strong>auto</strong> (C)</li>
<li>estruturas condicionais e laços de repetição (C)</li>
<li>vetores (C)</li>
<li>tipos agregados com <strong>struct</strong> ou
<strong>class/public:</strong> (C/C++)</li>
<li>agregados genéricos (C++)</li>
</ul>
</section></section>
<section>
<section id="parte-2-rotinas-ponteiros-e-conceitos-em-cc"
class="title-slide slide level1">
<h1>Parte 2: Rotinas, Ponteiros e Conceitos em C/C++</h1>

</section>
<section id="rotinas-i" class="slide level2">
<h2>Rotinas I</h2>
<p>A modularização de programas é muito importante, principalmente
quando trechos de código são repetidos muitas vezes.</p>
<p>Nesses casos, é comum criar rotinas, como <em>funções e
procedimentos</em>, que podem por sua vez receber parâmetros.</p>
<p>Tomemos por exemplo a função quadrado que retorna o valor passado
elevado ao quadrado.</p>
<div class="sourceCode" id="cb25"><pre
class="sourceCode .cpp"><code class="sourceCode cpp"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="co">// função que retorna um &#39;int&#39;, com parâmetro &#39;p&#39;</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> quadrado <span class="op">(</span><span class="dt">int</span> p<span class="op">)</span> <span class="op">-&gt;</span> <span class="dt">int</span> <span class="op">{</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>   <span class="cf">return</span> p<span class="op">*</span>p<span class="op">;</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a><span class="co">// variável do tipo &#39;int&#39;, com valor 25</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> x <span class="op">=</span> quadrado<span class="op">(</span><span class="dv">5</span><span class="op">);</span>        </span></code></pre></div>
<p><strong>Importante:</strong> a dedução do tipo após a seta
<code>-&gt;</code> é feita automaticamente.</p>
</section>
<section id="rotinas-ii" class="slide level2">
<h2>Rotinas II</h2>
<p>Quando nenhum valor é retornado (em um procedimento), utilizamos a
palavra-chave <code>void</code>. Procedimentos são úteis mesmo quando
nenhum valor é retornado. <strong>Exemplo</strong>: (de a até b):</p>
<div class="sourceCode" id="cb26"><pre
class="sourceCode .cpp"><code class="sourceCode cpp"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> imprime <span class="op">(</span><span class="dt">int</span> a<span class="op">,</span> <span class="dt">int</span> b<span class="op">)</span> <span class="op">-&gt;</span> <span class="dt">void</span> <span class="op">{</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>   <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> i<span class="op">=</span>a<span class="op">;</span> i<span class="op">&lt;</span>b<span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>      println<span class="op">(</span><span class="st">&quot;</span><span class="sc">{}</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">);</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Também é possível retornar múltiplos elementos (par ou tupla),
através de um <em>structured binding</em> com tuplas:</p>
<div class="sourceCode" id="cb27"><pre
class="sourceCode .cpp"><code class="sourceCode cpp"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> duplo<span class="op">(</span><span class="dt">int</span> p<span class="op">)</span> <span class="op">{</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>   <span class="cf">return</span> <span class="bu">std::</span>tuple<span class="op">{</span>p<span class="op">+</span><span class="dv">3</span><span class="op">,</span> p<span class="op">+</span><span class="fl">6.5</span><span class="op">};</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> <span class="op">[</span>x1<span class="op">,</span>x2<span class="op">]</span> <span class="op">=</span> duplo<span class="op">(</span><span class="dv">10</span><span class="op">);</span> <span class="co">// x1=13 x2=16.5</span></span></code></pre></div>
<p><strong>Perg.:</strong> qual tipo de retorno de ‘duplo’?
<strong>R:</strong> <code>std::tuple&lt;int, double&gt;</code>.</p>
</section>
<section id="ponteiros-i" class="slide level2">
<h2>Ponteiros I</h2>
<p>Os parâmetros são sempre copiados (em C) ao serem passados para uma
função ou procedimento. Como passar tipos complexos (estruturas e
vetores de muitos elementos) sem perder tempo?</p>
<p>Nestes casos, a linguagem C oferece um tipo especial denominado
ponteiro. A sintaxe do ponteiro simplesmente inclui um asterisco
(<code>*</code>) após o tipo da variável. Um estado vazio se faz com
<strong>nullptr</strong> (ou <code>0</code>).</p>
<p><strong>Exemplos:</strong>
<code>int* x = nullptr; struct P* p1 = nullptr</code>;</p>
<p>Um ponteiro simplesmente armazena <strong>o local</strong> (endereço)
onde determinada variável está armazenada na memória (basicamente, um
número). Então quando um ponteiro é passado como parâmetro, <strong>a
cópia do ponteiro</strong> pode ser utilizada para encontrar na memória
a estrutura desejada.</p>
<p>O tamanho do ponteiro varia de acordo com a arquitetura, mas para
endereçar 64-bits, ele ocupa 8 bytes.</p>
</section>
<section id="ponteiros-ii" class="slide level2">
<h2>Ponteiros II</h2>
<p>Em ponteiros para agregados, o operador de acesso (<code>.</code>) é
substituído por uma seta (<code>-&gt;</code>). O operador
<code>&amp;</code> toma o endereço da variável:</p>
<div class="sourceCode" id="cb28"><pre
class="sourceCode .cpp"><code class="sourceCode cpp"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> P <span class="op">{</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">public</span><span class="op">:</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>   <span class="dt">int32_t</span> x<span class="op">;</span> <span class="dt">char</span> y<span class="op">;</span> <span class="co">// mais alguma coisa gigante aqui?</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a><span class="co">// ...</span></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>P p0 <span class="op">=</span> <span class="op">{.</span>x <span class="op">=</span> <span class="dv">20</span><span class="op">,</span> <span class="op">.</span>y <span class="op">=</span> <span class="ch">&#39;Y&#39;</span><span class="op">};</span> </span></code></pre></div>
<p>Testando procedimentos <code>f</code> e <code>g</code>:</p>
<div class="columns">
<div class="column" style="width:50%;">
<div class="sourceCode" id="cb29"><pre
class="sourceCode .cpp"><code class="sourceCode cpp"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> f<span class="op">(</span>P<span class="op">*</span> p1<span class="op">)</span> <span class="op">-&gt;</span> <span class="dt">void</span> <span class="op">{</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>   println<span class="op">(</span><span class="st">&quot;</span><span class="sc">{}</span><span class="st">&quot;</span><span class="op">,</span> p1<span class="op">-&gt;</span>x<span class="op">);</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>   p1<span class="op">-&gt;</span>x <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>f<span class="op">(&amp;</span>p0<span class="op">);</span></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>println<span class="op">(</span><span class="st">&quot;</span><span class="sc">{}</span><span class="st">&quot;</span><span class="op">,</span> p0<span class="op">.</span>x<span class="op">);</span> <span class="co">// 1</span></span></code></pre></div>
</div><div class="column" style="width:50%;">
<div class="sourceCode" id="cb30"><pre
class="sourceCode .cpp"><code class="sourceCode cpp"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> g<span class="op">(</span>P p2<span class="op">)</span> <span class="op">-&gt;</span> <span class="dt">void</span> <span class="op">{</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>   println<span class="op">(</span><span class="st">&quot;</span><span class="sc">{}</span><span class="st">&quot;</span><span class="op">,</span> p2<span class="op">.</span>x<span class="op">);</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>   p2<span class="op">.</span>x <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>g<span class="op">(</span>p0<span class="op">);</span></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>println<span class="op">(</span><span class="st">&quot;</span><span class="sc">{}</span><span class="st">&quot;</span><span class="op">,</span> p0<span class="op">.</span>x<span class="op">);</span> <span class="co">// 20</span></span></code></pre></div>
</div>
</div>
</section>
<section id="alocação-dinâmica-de-memória" class="slide level2">
<h2>Alocação Dinâmica de Memória</h2>
<p>Programas frequentemente necessitam de alocar mais memória para uso,
o que é armazenado de forma segura em um ponteiro para o tipo da
memória:</p>
<div class="columns">
<div class="column" style="width:55%;">
<div class="sourceCode" id="cb31"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Aloca (C) o agregado P</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> P<span class="op">*</span> vp <span class="op">=</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>   malloc<span class="op">(</span><span class="dv">1</span><span class="op">*</span><span class="kw">sizeof</span><span class="op">(</span><span class="kw">struct</span> P<span class="op">));</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a><span class="co">// inicializa campos de P</span></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>vp<span class="op">-&gt;</span>x <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>vp<span class="op">-&gt;</span>y <span class="op">=</span> <span class="ch">&#39;Y&#39;</span><span class="op">;</span></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a><span class="co">// imprime x (valor 10)</span></span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a>printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> vp<span class="op">-&gt;</span>x<span class="op">);</span></span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a><span class="co">// descarta a memória</span></span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a>free<span class="op">(</span>vp<span class="op">);</span></span></code></pre></div>
</div><div class="column" style="width:45%;">
<div class="sourceCode" id="cb32"><pre
class="sourceCode .cpp"><code class="sourceCode cpp"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Aloca (C++) o agregado P</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span><span class="op">*</span> vp <span class="op">=</span> <span class="kw">new</span> P<span class="op">{</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>                  <span class="op">.</span>x <span class="op">=</span> <span class="dv">10</span><span class="op">,</span></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>                  <span class="op">.</span>y <span class="op">=</span> <span class="ch">&#39;Y&#39;</span></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>                <span class="op">};</span></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a><span class="co">// imprime x (valor 10)</span></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a>println<span class="op">(</span><span class="st">&quot;</span><span class="sc">{}</span><span class="st">&quot;</span><span class="op">,</span> vp<span class="op">-&gt;</span>x<span class="op">);</span></span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a><span class="co">// descarta a memória</span></span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a><span class="kw">delete</span> vp<span class="op">;</span></span></code></pre></div>
</div>
</div>
</section>
<section id="rotinas-iii" class="slide level2">
<h2>Rotinas III</h2>
<p>O tipo de uma função é basicamente um ponteiro (endereço) da
localização desta função na memória do computador. Por exemplo:</p>
<div class="columns">
<div class="column" style="width:55%;">
<div class="sourceCode" id="cb33"><pre
class="sourceCode .cpp"><code class="sourceCode cpp"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="co">// tipo: int(*)(int)</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> quadrado<span class="op">(</span><span class="dt">int</span> p<span class="op">)</span> <span class="op">{</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>   <span class="cf">return</span> p<span class="op">*</span>p<span class="op">;</span>      </span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div><div class="column" style="width:45%;">
<div class="sourceCode" id="cb34"><pre
class="sourceCode .cpp"><code class="sourceCode cpp"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="co">// tipo: float(*)(int)</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> fquad<span class="op">(</span><span class="dt">int</span> p<span class="op">)</span> <span class="op">-&gt;</span> <span class="dt">float</span><span class="op">{</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>   <span class="cf">return</span> p<span class="op">*</span>p<span class="op">;</span>      </span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div>
</div>
<p>Este fato pode ser útil para receber funções como parâmetro, bem como
armazenar funções anônimas (<em>lambdas</em>):</p>
<div class="sourceCode" id="cb35"><pre
class="sourceCode .cpp"><code class="sourceCode cpp"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="co">// armazena lambda no ponteiro de função &#39;quad&#39;</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span><span class="op">(*</span>quad<span class="op">)(</span><span class="dt">int</span><span class="op">)</span> <span class="op">=</span> <span class="op">[](</span><span class="dt">int</span> p<span class="op">)</span> <span class="op">-&gt;</span> <span class="dt">int</span> <span class="op">{</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>                     <span class="cf">return</span> p<span class="op">*</span>p<span class="op">;</span></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>                  <span class="op">};</span></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>println<span class="op">(</span><span class="st">&quot;</span><span class="sc">{}</span><span class="st">&quot;</span><span class="op">,</span> quad<span class="op">(</span><span class="dv">3</span><span class="op">));</span> <span class="co">// 9</span></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a><span class="co">// ou, utilizando &#39;auto&#39; para deduzir o tipo</span></span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> func <span class="op">=</span> <span class="op">[](</span><span class="dt">int</span> p<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> p<span class="op">*</span>p<span class="op">;</span> <span class="op">};</span></span></code></pre></div>
</section>
<section id="rotinas-iv" class="slide level2">
<h2>Rotinas IV</h2>
<p>A linguagem C++ permite a inclusão de funções e variáveis dentro de
agregados (em C, funções devem ser externas). Para acessar campos do
agregado de dentro dessas funções, utilize o <em>ponteiro para o
agregado</em>, chamado <strong>this</strong>:</p>
<div class="columns">
<div class="column" style="width:50%;">
<div class="sourceCode" id="cb36"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Em C (tipo agregado Z)</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Z <span class="op">{</span></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> x<span class="op">;</span></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a><span class="co">// imprime x negativo</span></span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> neg<span class="op">(</span><span class="kw">struct</span> Z<span class="op">*</span> this<span class="op">)</span></span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a>   printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> </span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true" tabindex="-1"></a>          <span class="op">-</span><span class="dv">1</span><span class="op">*(</span>this<span class="op">-&gt;</span>x<span class="op">));</span></span>
<span id="cb36-11"><a href="#cb36-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div><div class="column" style="width:50%;">
<div class="sourceCode" id="cb37"><pre
class="sourceCode .cpp"><code class="sourceCode cpp"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Em C++ (tipo agregado Z)</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Z <span class="op">{</span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">public</span><span class="op">:</span></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>   <span class="dt">int</span> x<span class="op">;</span></span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>   <span class="co">// imprime x negativo</span></span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a>   <span class="kw">auto</span> neg<span class="op">()</span> <span class="op">-&gt;</span> <span class="dt">void</span> <span class="op">{</span></span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a>      println<span class="op">(</span><span class="st">&quot;</span><span class="sc">{}</span><span class="st">&quot;</span><span class="op">,</span> </span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a>              <span class="op">-</span><span class="dv">1</span><span class="op">*(</span><span class="kw">this</span><span class="op">-&gt;</span>x<span class="op">));</span></span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true" tabindex="-1"></a>   <span class="op">}</span></span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
</div>
</div>
</section>
<section id="tipo-stdspan-na-stl" class="slide level2">
<h2>Tipo <code>std::span</code> na STL</h2>
<p>Como <code>std::string_view</code>, para demais vetores
<code>int[]</code>, <code>std::array</code> e <code>std::vector</code>,
o <code>std::span</code> suporta sequências de dados <em>sem
posse</em>.</p>
<div class="sourceCode" id="cb38"><pre
class="sourceCode .cpp"><code class="sourceCode cpp"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> std<span class="op">;</span>       <span class="co">// invocando ./programa 1 2 3</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> main<span class="op">(</span><span class="dt">int</span> argc<span class="op">,</span> <span class="dt">char</span><span class="op">*</span> argv<span class="op">[])</span> <span class="op">-&gt;</span> <span class="dt">int</span> <span class="op">{</span></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>   <span class="dt">int</span> v2<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">};</span></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>   <span class="bu">std::</span>span<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> s1<span class="op">{</span>v2<span class="op">};</span></span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>   <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> i <span class="op">:</span> s1<span class="op">)</span> <span class="bu">std::</span>println<span class="op">(</span><span class="st">&quot;</span><span class="sc">{}</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">);</span></span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a>   <span class="co">// 1 2 3 4</span></span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a>   <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> vec <span class="op">=</span> <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">};</span></span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a>   <span class="bu">std::</span>span<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> s2<span class="op">{</span>vec<span class="op">};</span></span>
<span id="cb38-9"><a href="#cb38-9" aria-hidden="true" tabindex="-1"></a>   <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> i <span class="op">:</span> s2<span class="op">)</span> <span class="bu">std::</span>println<span class="op">(</span><span class="st">&quot;</span><span class="sc">{}</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">);</span></span>
<span id="cb38-10"><a href="#cb38-10" aria-hidden="true" tabindex="-1"></a>   <span class="co">// 1 2 3 4</span></span>
<span id="cb38-11"><a href="#cb38-11" aria-hidden="true" tabindex="-1"></a>   <span class="bu">std::</span>span<span class="op">&lt;</span><span class="dt">char</span><span class="op">*&gt;</span> entrada<span class="op">{</span>argv<span class="op">,</span> argc<span class="op">};</span></span>
<span id="cb38-12"><a href="#cb38-12" aria-hidden="true" tabindex="-1"></a>   <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> i <span class="op">:</span> entrada<span class="op">)</span> <span class="bu">std::</span>println<span class="op">(</span><span class="st">&quot;</span><span class="sc">{}</span><span class="st">&quot;</span><span class="op">,</span> i<span class="op">);</span></span>
<span id="cb38-13"><a href="#cb38-13" aria-hidden="true" tabindex="-1"></a>   <span class="co">// ./programa 1 2 3</span></span>
<span id="cb38-14"><a href="#cb38-14" aria-hidden="true" tabindex="-1"></a>   <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb38-15"><a href="#cb38-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="co">// ============================================</span></span></code></pre></div>
</section>
<section id="tipo-stdoptional-na-stl" class="slide level2">
<h2>Tipo <code>std::optional</code> na STL</h2>
<p>O <code>std::optional&lt;tipo&gt;</code> representa um valor
opcional, com alocação em <em>stack</em>, não em <em>heap</em> como
ponteiros (e <em>smart pointers</em>, que veremos a seguir). O acesso se
faz com operador (<code>*</code>).</p>
<div class="sourceCode" id="cb39"><pre
class="sourceCode .cpp"><code class="sourceCode cpp"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> busca<span class="op">(</span><span class="dt">char</span> c<span class="op">,</span> <span class="bu">std::</span>span<span class="op">&lt;</span><span class="dt">char</span><span class="op">&gt;</span> v<span class="op">)</span> <span class="op">-&gt;</span> <span class="bu">std::</span>optional<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">// busca char &#39;c&#39; num vetor v e retorna posição</span></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> v<span class="op">.</span>size<span class="op">();</span> i<span class="op">++)</span></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>v<span class="op">[</span>i<span class="op">]</span> <span class="op">==</span> c<span class="op">)</span> <span class="cf">return</span> i<span class="op">;</span>  <span class="co">// encontrou</span></span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">// não encontrou</span></span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="bu">std::</span>nullopt<span class="op">;</span></span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a><span class="co">// ...</span></span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">char</span><span class="op">&gt;</span> v <span class="op">=</span> <span class="op">{</span><span class="ch">&#39;a&#39;</span><span class="op">,</span> <span class="ch">&#39;b&#39;</span><span class="op">,</span> <span class="ch">&#39;c&#39;</span><span class="op">};</span></span>
<span id="cb39-10"><a href="#cb39-10" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> op <span class="op">=</span> busca<span class="op">(</span><span class="ch">&#39;x&#39;</span><span class="op">,</span> v<span class="op">);</span></span>
<span id="cb39-11"><a href="#cb39-11" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span><span class="op">(</span>op<span class="op">)</span> println<span class="op">(</span><span class="st">&quot;posicao=</span><span class="sc">{}</span><span class="st">&quot;</span><span class="op">,</span> <span class="op">*</span>op<span class="op">);</span></span>
<span id="cb39-12"><a href="#cb39-12" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>   println<span class="op">(</span><span class="st">&quot;não encontrou&quot;</span><span class="op">);</span></span></code></pre></div>
</section>
<section id="tipo-stdexpected-na-stl" class="slide level2">
<h2>Tipo <code>std::expected</code> na STL</h2>
<p>O <code>std::expected&lt;tipo, tipo_erro&gt;</code> representa um
valor <em>esperado</em>, com alocação em <em>stack</em>, não em
<em>heap</em> como ponteiros (e <em>smart pointers</em>, que veremos a
seguir). O acesso se faz com operador (<code>*</code>).</p>
<div class="sourceCode" id="cb40"><pre
class="sourceCode .cpp"><code class="sourceCode cpp"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> busca2<span class="op">(</span><span class="dt">char</span> c<span class="op">,</span> <span class="bu">std::</span>span<span class="op">&lt;</span><span class="dt">char</span><span class="op">&gt;</span> v<span class="op">)</span> </span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>                       <span class="op">-&gt;</span> <span class="bu">std::</span>expected<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="bu">std::</span>string<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">// busca char &#39;c&#39; num vetor v e retorna posição</span></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> v<span class="op">.</span>size<span class="op">();</span> i<span class="op">++)</span></span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>v<span class="op">[</span>i<span class="op">]</span> <span class="op">==</span> c<span class="op">)</span> <span class="cf">return</span> i<span class="op">;</span>  <span class="co">// encontrou</span></span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="bu">std::</span>unexpected<span class="op">{</span><span class="st">&quot;não encontrou&quot;</span><span class="op">};</span></span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a><span class="co">// ...</span></span>
<span id="cb40-9"><a href="#cb40-9" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">char</span><span class="op">&gt;</span> v <span class="op">=</span> <span class="op">{</span><span class="ch">&#39;a&#39;</span><span class="op">,</span> <span class="ch">&#39;b&#39;</span><span class="op">,</span> <span class="ch">&#39;c&#39;</span><span class="op">};</span></span>
<span id="cb40-10"><a href="#cb40-10" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> exp <span class="op">=</span> busca2<span class="op">(</span><span class="ch">&#39;x&#39;</span><span class="op">,</span> v<span class="op">);</span></span>
<span id="cb40-11"><a href="#cb40-11" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span><span class="op">(</span>exp<span class="op">)</span> println<span class="op">(</span><span class="st">&quot;posicao=</span><span class="sc">{}</span><span class="st">&quot;</span><span class="op">,</span> <span class="op">*</span>exp<span class="op">);</span></span>
<span id="cb40-12"><a href="#cb40-12" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>    println<span class="op">(</span><span class="st">&quot;</span><span class="sc">{}</span><span class="st">&quot;</span><span class="op">,</span> exp<span class="op">.</span>error<span class="op">());</span></span></code></pre></div>
</section></section>
<section>
<section id="parte-3-tipos-abstratos-e-conceitos"
class="title-slide slide level1">
<h1>Parte 3: Tipos Abstratos e Conceitos</h1>

</section>
<section id="conceitos-i" class="slide level2">
<h2>Conceitos I</h2>
<p>C++20 traz a possibilidade de definir conceitos (ou
<em>concepts</em>). Esse recurso permite <em>definições genéricas</em>
sobre algum tipo (inclusive tipos agregados com funções internas).</p>
<p>Por exemplo, podemos criar um <em>conceito</em>
<code>TemNegativo</code>, que exige que o agregado possua um método
<code>neg()</code>:</p>
<div class="sourceCode" id="cb41"><pre
class="sourceCode .cpp"><code class="sourceCode cpp"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> Agregado<span class="op">&gt;</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a><span class="kw">concept</span> TemNegativo <span class="op">=</span> <span class="kw">requires</span><span class="op">(</span>Agregado a<span class="op">)</span> <span class="op">{</span></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">{</span> a<span class="op">.</span>neg<span class="op">()</span> <span class="op">}</span> <span class="op">-&gt;</span> <span class="bu">std::</span>same_as<span class="op">&lt;</span><span class="dt">void</span><span class="op">&gt;;</span></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>Exemplo de agregado de acordo com conceito
<code>TemNegativo</code>:</p>
<div class="sourceCode" id="cb42"><pre
class="sourceCode .cpp"><code class="sourceCode cpp"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Z <span class="op">{</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">public</span><span class="op">:</span></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>   <span class="dt">int</span> x<span class="op">;</span></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>   <span class="kw">auto</span> neg<span class="op">()</span> <span class="op">-&gt;</span> <span class="dt">void</span> <span class="op">{</span> println<span class="op">(</span><span class="st">&quot;</span><span class="sc">{}</span><span class="st">&quot;</span><span class="op">,</span> <span class="op">-</span><span class="dv">1</span><span class="op">*(</span><span class="kw">this</span><span class="op">-&gt;</span>x<span class="op">));</span> <span class="op">}</span></span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
</section>
<section id="conceitos-ii" class="slide level2">
<h2>Conceitos II</h2>
<p>Assim, podemos utilizar um conceito mais específico ao invés de um
tipo automático:</p>
<div class="sourceCode" id="cb43"><pre
class="sourceCode .cpp"><code class="sourceCode cpp"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> a1             <span class="op">=</span> Z<span class="op">{.</span>x <span class="op">=</span> <span class="dv">1</span><span class="op">};</span>  <span class="co">// tipo automático</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>TemNegativo <span class="kw">auto</span> a2 <span class="op">=</span> Z<span class="op">{.</span>x <span class="op">=</span> <span class="dv">2</span><span class="op">};</span>  <span class="co">// tipo conceitual</span></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>Z a3                <span class="op">=</span> Z<span class="op">{.</span>x <span class="op">=</span> <span class="dv">3</span><span class="op">};</span>  <span class="co">// tipo explícito</span></span></code></pre></div>
<p>Outra forma de validação de tipos em <em>tempo de compilação</em> é o
<code>static_assert</code>. Por exemplo, como garantir que a classe Z
está de acordo com o conceito TemNegativo?</p>
<div class="sourceCode" id="cb44"><pre
class="sourceCode .cpp"><code class="sourceCode cpp"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="kw">static_assert</span><span class="op">(</span>TemNegativo<span class="op">&lt;</span>Z<span class="op">&gt;);</span></span></code></pre></div>
<p><strong>Importante:</strong> a noção de <em>conceitos</em> é
fundamental para a compreensão de <em>tipos abstratos</em>, central no
curso de estruturas de dados.</p>
</section></section>
<section>
<section id="parte-4-ponteiros-inteligentes-e-referências-em-c"
class="title-slide slide level1">
<h1>Parte 4: Ponteiros Inteligentes e Referências em C++</h1>

</section>
<section id="ponteiros-iii" class="slide level2">
<h2>Ponteiros III</h2>
<p>Ponteiros são estruturas reconhecidamente problemáticas, portanto
desde a revisão C++11 é recomendado que se use <em>ponteiros
inteligentes</em> (ou <em>smart pointers</em>) ao invés de ponteiros
nativos. Existem dois tipos de smart pointers: <code>unique_ptr</code> e
<code>shared_ptr</code>. Ambos evitam que o usuário precise de desalocar
memória (<em>com exceção de estruturas cíclicas, a serem abordadas no
futuro</em>). Para utilizá-los, basta incluir o cabeçalho
<code>&lt;memory&gt;</code>, e substituir o <code>new</code> por
<code>std::make_unique</code> ou <code>std::make_shared</code>.</p>
<div class="columns">
<div class="column" style="width:50%;">
<div class="sourceCode" id="cb45"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Aloca (C++) agregado P</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span><span class="op">*</span> vp <span class="op">=</span> <span class="kw">new</span> P<span class="op">{</span></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>                  <span class="op">.</span>x <span class="op">=</span> <span class="dv">10</span><span class="op">,</span></span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a>                  <span class="op">.</span>y <span class="op">=</span> <span class="ch">&#39;Y&#39;</span></span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a>                <span class="op">};</span></span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a><span class="co">// imprime x (valor 10)</span></span>
<span id="cb45-7"><a href="#cb45-7" aria-hidden="true" tabindex="-1"></a>print<span class="op">(</span><span class="st">&quot;</span><span class="sc">{}\n</span><span class="st">&quot;</span><span class="op">,</span> vp<span class="op">-&gt;</span>x<span class="op">);</span></span>
<span id="cb45-8"><a href="#cb45-8" aria-hidden="true" tabindex="-1"></a><span class="co">// descarta a memória</span></span>
<span id="cb45-9"><a href="#cb45-9" aria-hidden="true" tabindex="-1"></a><span class="kw">delete</span> vp<span class="op">;</span></span></code></pre></div>
</div><div class="column" style="width:50%;">
<div class="sourceCode" id="cb46"><pre
class="sourceCode .cpp"><code class="sourceCode cpp"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Aloca (C++) agregado P</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> vp <span class="op">=</span> <span class="bu">std::</span>make_unique<span class="op">&lt;</span>P<span class="op">&gt;(</span></span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a>     P<span class="op">{.</span>x <span class="op">=</span> <span class="dv">10</span><span class="op">,</span> <span class="op">.</span>y <span class="op">=</span> <span class="ch">&#39;Y&#39;</span><span class="op">});</span></span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a><span class="co">// imprime x (valor 10)</span></span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a>print<span class="op">(</span><span class="st">&quot;</span><span class="sc">{}\n</span><span class="st">&quot;</span><span class="op">,</span> vp<span class="op">-&gt;</span>x<span class="op">);</span></span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a><span class="co">// descarta a memória</span></span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true" tabindex="-1"></a><span class="co">// delete vp;</span></span></code></pre></div>
</div>
</div>
</section>
<section id="ponteiros-iv" class="slide level2">
<h2>Ponteiros IV</h2>
<p>Ponteiros podem ser utilizados como marcadores de um espaço de
memória inválido, geralmente chamado de <em>nulo</em>. Em C, a macro
<code>NULL</code> é geralmente definida como zero, sendo então uma
melhor prática usar o número zero diretamente ao invés de
<code>NULL</code>. O condicional pode ser usado para verificar um
ponteiro como booleano, que é a opção mais segura. Em C++, existe o
<code>std::nullptr</code>, que pode ser utilizado em situações
específicas (geralmente <em>smart pointers</em>), mas geralmente evite
<code>NULL</code> e <code>std::nullptr</code>.</p>
<div class="columns">
<div class="column" style="width:55%;">
<div class="sourceCode" id="cb47"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Aloca (C++) o agregado P</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span><span class="op">*</span> vp <span class="op">=</span> <span class="kw">new</span> P<span class="op">{</span></span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>                  <span class="op">.</span>x <span class="op">=</span> <span class="dv">10</span><span class="op">,</span></span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a>                  <span class="op">.</span>y <span class="op">=</span> <span class="ch">&#39;Y&#39;</span></span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a>                <span class="op">};</span></span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span><span class="op">(</span>vp<span class="op">)</span>  print<span class="op">(</span><span class="st">&quot;sucesso!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb47-7"><a href="#cb47-7" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span><span class="op">(!</span>vp<span class="op">)</span>      print<span class="op">(</span><span class="st">&quot;falha!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb47-8"><a href="#cb47-8" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span><span class="op">(</span>vp<span class="op">==</span>NULL<span class="op">)</span> print<span class="op">(</span><span class="st">&quot;falha!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb47-9"><a href="#cb47-9" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span><span class="op">(</span>vp<span class="op">==</span><span class="dv">0</span><span class="op">)</span>    print<span class="op">(</span><span class="st">&quot;falha!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span></code></pre></div>
</div><div class="column" style="width:45%;">
<div class="sourceCode" id="cb48"><pre
class="sourceCode .cpp"><code class="sourceCode cpp"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Aloca (C++) o agregado P</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> vp <span class="op">=</span> </span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>   <span class="bu">std::</span>make_unique<span class="op">&lt;</span>P<span class="op">&gt;(</span></span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>     P<span class="op">{.</span>x <span class="op">=</span> <span class="dv">10</span><span class="op">,</span> <span class="op">.</span>y <span class="op">=</span> <span class="ch">&#39;Y&#39;</span><span class="op">});</span></span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span><span class="op">(</span>vp<span class="op">)</span>  print<span class="op">(</span><span class="st">&quot;sucesso!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span><span class="op">(!</span>vp<span class="op">)</span> print<span class="op">(</span><span class="st">&quot;falha!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb48-7"><a href="#cb48-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-8"><a href="#cb48-8" aria-hidden="true" tabindex="-1"></a><span class="co">// reseta manualmente</span></span>
<span id="cb48-9"><a href="#cb48-9" aria-hidden="true" tabindex="-1"></a>vp <span class="op">=</span> <span class="bu">std::</span>nullptr<span class="op">;</span></span></code></pre></div>
</div>
</div>
</section>
<section id="passagem-de-parâmetros-por-referência-i"
class="slide level2">
<h2>Passagem de Parâmetros por Referência I</h2>
<p>Em C, só é possível passar variáveis por cópia, o que demanda uso de
ponteiros para evitar cópias volumosas e desnecessárias.</p>
<p>Em C++, existem os conceitos de <em>referência de lado esquerdo</em>
<code>(&amp;)</code> e <em>referência de lado direito</em>
<code>(&amp;&amp;)</code>. Em resumo, utilizamos um
<code>tipo&amp;</code> para denotar uma <em>referência a um dado
vivo</em>, e <code>tipo&amp;&amp;</code> para uma <em>referência a um
dado prestes a morrer</em> (ou <em>dado em movimento</em>). Esse
conceito é fundamental para lidar com <code>unique_ptr</code>, pois eles
não permitem cópias, sendo obrigatoriamente passados por referência.</p>
<p>Para transformar uma <em>variável viva</em> para uma <em>variável em
movimento</em>, basta usar o comando <code>std::move</code>.</p>
<div class="sourceCode" id="cb49"><pre
class="sourceCode .cpp"><code class="sourceCode cpp"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> p1 <span class="op">=</span> <span class="bu">std::</span>make_unique<span class="op">&lt;</span>P<span class="op">&gt;(</span>P<span class="op">{.</span>x <span class="op">=</span> <span class="dv">10</span><span class="op">,</span> <span class="op">.</span>y <span class="op">=</span> <span class="ch">&#39;Y&#39;</span><span class="op">});</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>println<span class="op">(</span><span class="st">&quot;</span><span class="sc">{}</span><span class="st">&quot;</span><span class="op">,</span> p1<span class="op">-&gt;</span>x<span class="op">);</span> <span class="co">// imprime x (valor 10)</span></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> p2 <span class="op">=</span> <span class="bu">std::</span>move<span class="op">(</span>p1<span class="op">);</span></span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span><span class="op">(!</span>p1<span class="op">)</span> print<span class="op">(</span><span class="st">&quot;p1 não existe mais!</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a>println<span class="op">(</span><span class="st">&quot;</span><span class="sc">{}</span><span class="st">&quot;</span><span class="op">,</span> p2<span class="op">-&gt;</span>x<span class="op">);</span> <span class="co">// imprime x (valor 10)</span></span></code></pre></div>
</section></section>
<section>
<section id="parte-5-corrotinas-tópico-avançado"
class="title-slide slide level1">
<h1>Parte 5: Corrotinas (tópico avançado)</h1>

</section>
<section id="corrotinas-i-coroutines" class="slide level2">
<h2>Corrotinas I (Coroutines)</h2>
<p>Além das clássicas <em>rotinas</em>, que retornam (ou não) valores,
existem também <em>corrotinas</em>, com capacidade de <em>paralisar e
retomar</em> a execução.</p>
<p>Um exemplo é a <em>sequência de fibonacci</em>, que começa de 0, 1, e
segue com a soma dos <em>dois últimos elementos</em>. Essa é uma
<em>sequência infinita</em>, e podemos facilmente representá-la assim
que retornos <code>co_yield</code> de corrotina com
<code>std::generator</code>:</p>
<div class="sourceCode" id="cb50"><pre
class="sourceCode .cpp"><code class="sourceCode cpp"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> fibonacci<span class="op">()</span> <span class="op">-&gt;</span> <span class="bu">std::</span>generator<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> b <span class="op">=</span> <span class="dv">1</span><span class="op">,</span> a <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span> <span class="op">(</span><span class="kw">true</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">co_yield</span> b<span class="op">;</span></span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// a, b &lt;- b, b+a      </span></span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> b2 <span class="op">=</span> a <span class="op">+</span> b<span class="op">;</span> a <span class="op">=</span> b<span class="op">;</span> b <span class="op">=</span> b2<span class="op">;</span></span>
<span id="cb50-7"><a href="#cb50-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb50-8"><a href="#cb50-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</section>
<section id="corrotinas-ii-coroutines" class="slide level2">
<h2>Corrotinas II (Coroutines)</h2>
<p>Para consumir os valores, basta usar o for range (todos Fib menores
que 10):</p>
<div class="sourceCode" id="cb51"><pre
class="sourceCode .cpp"><code class="sourceCode cpp"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> num <span class="op">:</span> fibonacci<span class="op">())</span> <span class="op">{</span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a>   <span class="cf">if</span> <span class="op">(</span>num <span class="op">&gt;</span> <span class="dv">10</span><span class="op">)</span> <span class="cf">break</span><span class="op">;</span></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a>   <span class="cf">else</span> <span class="bu">std::</span>println<span class="op">(</span><span class="st">&quot;</span><span class="sc">{}</span><span class="st">&quot;</span><span class="op">,</span> num<span class="op">);</span>  <span class="co">// 1 1 2 3 5 8</span></span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><strong>Desafio:</strong> como implementar essa mesma funcionalidade
sem corrotina?</p>
<p><strong>Desafio 2:</strong> outro uso é o <code>std::future</code>
com corrotinas conectadas a programação concorrente com threads. Isso
foge um pouco do escopo desse curso, mas verifique outras aplicações de
corrotinas e <code>co_await</code>.</p>
</section></section>
<section>
<section id="parte-6-referências-em-c-tópico-avançado"
class="title-slide slide level1">
<h1>Parte 6: Referências em C++ (tópico avançado)</h1>

</section>
<section id="passagem-de-parâmetros-por-referência-ii"
class="slide level2">
<h2>Passagem de Parâmetros por Referência II</h2>
<div class="columns">
<div class="column" style="width:50%;">
<div class="sourceCode" id="cb52"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="co">// C++</span></span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> imprimex<span class="op">(</span>P<span class="op">*</span> vp<span class="op">)</span> <span class="op">-&gt;</span> <span class="dt">void</span> <span class="op">{</span></span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">// imprime x (valor 10)</span></span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a>  println<span class="op">(</span><span class="st">&quot;</span><span class="sc">{}</span><span class="st">&quot;</span><span class="op">,</span> vp<span class="op">-&gt;</span>x<span class="op">);</span></span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true" tabindex="-1"></a><span class="co">// ...</span></span>
<span id="cb52-7"><a href="#cb52-7" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> p <span class="op">=</span> P<span class="op">{</span></span>
<span id="cb52-8"><a href="#cb52-8" aria-hidden="true" tabindex="-1"></a>         <span class="op">.</span>x <span class="op">=</span> <span class="dv">10</span><span class="op">,</span></span>
<span id="cb52-9"><a href="#cb52-9" aria-hidden="true" tabindex="-1"></a>         <span class="op">.</span>y <span class="op">=</span> <span class="ch">&#39;Y&#39;</span></span>
<span id="cb52-10"><a href="#cb52-10" aria-hidden="true" tabindex="-1"></a>         <span class="op">};</span></span>
<span id="cb52-11"><a href="#cb52-11" aria-hidden="true" tabindex="-1"></a><span class="co">// cópia de ponteiro</span></span>
<span id="cb52-12"><a href="#cb52-12" aria-hidden="true" tabindex="-1"></a>imprimex<span class="op">(&amp;</span>p<span class="op">);</span></span></code></pre></div>
</div><div class="column" style="width:50%;">
<div class="sourceCode" id="cb53"><pre
class="sourceCode .cpp"><code class="sourceCode cpp"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="co">// C++</span></span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> imprimex<span class="op">(</span>P<span class="op">&amp;</span> vp<span class="op">)</span> <span class="op">-&gt;</span> <span class="dt">void</span> <span class="op">{</span></span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">// imprime x (valor 10)</span></span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a>  println<span class="op">(</span><span class="st">&quot;</span><span class="sc">{}</span><span class="st">&quot;</span><span class="op">,</span> vp<span class="op">.</span>x<span class="op">);</span></span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb53-6"><a href="#cb53-6" aria-hidden="true" tabindex="-1"></a><span class="co">// ...</span></span>
<span id="cb53-7"><a href="#cb53-7" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> p <span class="op">=</span> P<span class="op">{</span></span>
<span id="cb53-8"><a href="#cb53-8" aria-hidden="true" tabindex="-1"></a>         <span class="op">.</span>x <span class="op">=</span> <span class="dv">10</span><span class="op">,</span></span>
<span id="cb53-9"><a href="#cb53-9" aria-hidden="true" tabindex="-1"></a>         <span class="op">.</span>y <span class="op">=</span> <span class="ch">&#39;Y&#39;</span></span>
<span id="cb53-10"><a href="#cb53-10" aria-hidden="true" tabindex="-1"></a>         <span class="op">};</span></span>
<span id="cb53-11"><a href="#cb53-11" aria-hidden="true" tabindex="-1"></a><span class="co">// referência (lvalue)</span></span>
<span id="cb53-12"><a href="#cb53-12" aria-hidden="true" tabindex="-1"></a>imprimex<span class="op">(</span>p<span class="op">);</span></span></code></pre></div>
</div>
</div>
</section>
<section id="passagem-de-parâmetros-por-referência-iii"
class="slide level2">
<h2>Passagem de Parâmetros por Referência III</h2>
<p>Referências de lado esquerdo (<em>lvalue</em>) complementam
referências de lado direito (<em>rvalue</em>). Observe:</p>
<div class="columns">
<div class="column" style="width:55%;">
<div class="sourceCode" id="cb54"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> teste1<span class="op">(</span><span class="dt">int</span> x<span class="op">)</span> <span class="op">{</span> </span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a>   x <span class="op">=</span> <span class="dv">10</span><span class="op">;</span> </span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> teste2<span class="op">(</span><span class="dt">int</span><span class="op">*</span> x<span class="op">)</span> <span class="op">{</span> </span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a>   <span class="op">*</span>x <span class="op">=</span> <span class="dv">10</span><span class="op">;</span> </span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb54-7"><a href="#cb54-7" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> teste3<span class="op">(</span><span class="dt">int</span><span class="op">&amp;</span> x<span class="op">)</span> <span class="op">{</span> </span>
<span id="cb54-8"><a href="#cb54-8" aria-hidden="true" tabindex="-1"></a>   x <span class="op">=</span> <span class="dv">10</span><span class="op">;</span> </span>
<span id="cb54-9"><a href="#cb54-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb54-10"><a href="#cb54-10" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> teste4<span class="op">(</span><span class="dt">int</span><span class="op">&amp;&amp;</span> x<span class="op">)</span> <span class="op">{</span> </span>
<span id="cb54-11"><a href="#cb54-11" aria-hidden="true" tabindex="-1"></a>   x <span class="op">=</span> <span class="dv">10</span><span class="op">;</span> </span>
<span id="cb54-12"><a href="#cb54-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</div><div class="column" style="width:45%;">
<div class="sourceCode" id="cb55"><pre
class="sourceCode .cpp"><code class="sourceCode cpp"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a <span class="op">=</span> <span class="dv">20</span><span class="op">;</span></span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a>teste1<span class="op">(</span>a<span class="op">);</span>     <span class="co">// a == 20</span></span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a>teste2<span class="op">(&amp;</span>a<span class="op">);</span>    <span class="co">// a &lt;- 10</span></span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a>teste3<span class="op">(</span>a<span class="op">);</span>     <span class="co">// a &lt;- 10</span></span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a><span class="co">// teste4(a);  // ERRO</span></span>
<span id="cb55-6"><a href="#cb55-6" aria-hidden="true" tabindex="-1"></a>teste4<span class="op">(</span><span class="bu">std::</span>move<span class="op">(</span>a<span class="op">));</span> <span class="co">// OK</span></span>
<span id="cb55-7"><a href="#cb55-7" aria-hidden="true" tabindex="-1"></a><span class="co">// supostamente a &lt;- 10</span></span>
<span id="cb55-8"><a href="#cb55-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-9"><a href="#cb55-9" aria-hidden="true" tabindex="-1"></a>teste1<span class="op">(</span><span class="dv">20</span><span class="op">);</span>     <span class="co">// OK</span></span>
<span id="cb55-10"><a href="#cb55-10" aria-hidden="true" tabindex="-1"></a><span class="co">// teste2(20);  // ERRO</span></span>
<span id="cb55-11"><a href="#cb55-11" aria-hidden="true" tabindex="-1"></a><span class="co">// teste3(20);  // ERRO</span></span>
<span id="cb55-12"><a href="#cb55-12" aria-hidden="true" tabindex="-1"></a>teste4<span class="op">(</span><span class="dv">20</span><span class="op">);</span>     <span class="co">// OK</span></span></code></pre></div>
</div>
</div>
<p><strong>Observação:</strong> existe também a sintaxe
<code>const tipo&amp;</code> que permite <em>lifetime extension</em>,
algo que não exploraremos nessa breve revisão.</p>
</section>
<section id="tipo-stdunique_ptr" class="slide level2">
<h2>Tipo <code>std::unique_ptr</code></h2>
<p>O <code>std::unique_ptr&lt;tipo&gt;</code> representa um ponteiro
único para o <code>tipo</code> (como se fosse <code>tipo*</code>). Uma
função útil é o <code>get</code>, que retorna um ponteiro nativo C para
o dado. A função <code>reset</code> apaga o ponteiro manualmente.</p>
<div class="sourceCode" id="cb56"><pre
class="sourceCode .cpp"><code class="sourceCode cpp"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span><span class="op">*</span> p1 <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">{</span><span class="dv">10</span><span class="op">};</span></span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span><span class="op">*</span> p2 <span class="op">=</span> p1<span class="op">;</span></span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a>println<span class="op">(</span><span class="st">&quot;*p1=</span><span class="sc">{}</span><span class="st"> *p2=</span><span class="sc">{}</span><span class="st">&quot;</span><span class="op">,</span> <span class="op">*</span>p1<span class="op">,</span> <span class="op">*</span>p2<span class="op">);</span></span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a><span class="co">// *p1=10 *p2=10</span></span>
<span id="cb56-5"><a href="#cb56-5" aria-hidden="true" tabindex="-1"></a><span class="kw">delete</span> p1<span class="op">;</span></span>
<span id="cb56-6"><a href="#cb56-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-7"><a href="#cb56-7" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> u1 <span class="op">=</span> <span class="bu">std::</span>make_unique<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span><span class="dv">10</span><span class="op">);</span></span>
<span id="cb56-8"><a href="#cb56-8" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> u2 <span class="op">=</span> <span class="bu">std::</span>move<span class="op">(</span>u1<span class="op">);</span></span>
<span id="cb56-9"><a href="#cb56-9" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span><span class="op">*</span> p3 <span class="op">=</span> u2<span class="op">.</span>get<span class="op">();</span></span>
<span id="cb56-10"><a href="#cb56-10" aria-hidden="true" tabindex="-1"></a>println<span class="op">(</span><span class="st">&quot;*u2=</span><span class="sc">{}</span><span class="st"> *p3=</span><span class="sc">{}</span><span class="st">&quot;</span><span class="op">,</span> <span class="op">*</span>u2<span class="op">,</span> <span class="op">*</span>p3<span class="op">);</span></span>
<span id="cb56-11"><a href="#cb56-11" aria-hidden="true" tabindex="-1"></a><span class="co">// *u2=10 *p3=10</span></span>
<span id="cb56-12"><a href="#cb56-12" aria-hidden="true" tabindex="-1"></a>u2<span class="op">.</span>reset<span class="op">();</span>   <span class="co">// apaga ponteiro u2 manualmente</span></span>
<span id="cb56-13"><a href="#cb56-13" aria-hidden="true" tabindex="-1"></a>u2 <span class="op">=</span> <span class="kw">nullptr</span><span class="op">;</span> <span class="co">// apaga ponteiro u2 manualmente</span></span></code></pre></div>
</section></section>
<section>
<section id="parte-7-bibliotecas-experimentais-e-avançadas-em-c"
class="title-slide slide level1">
<h1>Parte 7: Bibliotecas experimentais e avançadas em C++</h1>

</section>
<section id="o-que-é-biblioteca-padrão-stl" class="slide level2">
<h2>O que é biblioteca padrão STL?</h2>
<p>A biblioteca padrão da linguagem tem componentes já testados e de uso
comum, resolvendo diversos problemas básicos de programação. C++ possui
implementações bastante importantes em sua biblioteca padrão, chamada
STL. Antigamente, era necessário utilizar
<code>#include&lt;...&gt;</code> para incluir esses componentes, mas
desde o C++23 é possível fazer tudo automaticamente com um
<code>import std</code>, utilizando a estrutura moderna dos CXX
Modules.</p>
<p>Já vimos indiretamente o uso de algumas dessas estruturas no curso,
como: tuplas em <code>std::tuple</code>; ponteiros inteligentes em
<code>std::make_unique</code> ou <code>std::make_shared</code>; entre
outras coisas. Também vimos exemplos de estruturas muito fundamentais
como: <code>std::string</code> e <code>std::vector</code>. Geralmente,
propostas são feitas pela comunidade, e boas implementações são
incorporadas à biblioteca padrão, em revisões futuras da linguagem.</p>
</section>
<section id="tipo-stdshared_ptr-avançado" class="slide level2">
<h2>Tipo <code>std::shared_ptr</code> (avançado)</h2>
<p>O <code>std::shared_ptr&lt;tipo&gt;</code> representa um ponteiro
compartilhado para o <code>tipo</code> (como se fosse
<code>tipo*</code>). Uma função útil é o <code>get</code>, que retorna
um ponteiro nativo C para o dado. A função <code>reset</code> apaga o
ponteiro manualmente. O shared permite cópias e compartilhamento,
através de <em>reference counting</em>. Tome cuidado com ciclos, pois
podem acarretar vazamento de memória! Para isso, utilize
<code>std::weak_ptr</code> ou <code>cycles::relation_ptr</code> (a
seguir). Para utilizar, basta fazer
<code>#include &lt;memory&gt;</code>. Exemplo:</p>
<div class="sourceCode" id="cb57"><pre
class="sourceCode .cpp"><code class="sourceCode cpp"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> s1 <span class="op">=</span> <span class="bu">std::</span>make_shared<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span><span class="dv">10</span><span class="op">);</span></span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> s2 <span class="op">=</span> s1<span class="op">;</span></span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>weak_ptr<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> w1 <span class="op">=</span> s1<span class="op">;</span></span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> s3 <span class="op">=</span> w1<span class="op">.</span>lock<span class="op">();</span></span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a>println<span class="op">(</span><span class="st">&quot;*s1=</span><span class="sc">{}</span><span class="st"> *s2=</span><span class="sc">{}</span><span class="st"> *s3=</span><span class="sc">{}</span><span class="st">&quot;</span><span class="op">,</span> <span class="op">*</span>s1<span class="op">,</span> <span class="op">*</span>s2<span class="op">,</span> <span class="op">*</span>s3<span class="op">);</span></span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true" tabindex="-1"></a><span class="co">// *s1=10 *s2=10 *s3=10</span></span>
<span id="cb57-7"><a href="#cb57-7" aria-hidden="true" tabindex="-1"></a>s1<span class="op">.</span>reset<span class="op">();</span> <span class="co">// apaga ponteiro s1 manualmente</span></span>
<span id="cb57-8"><a href="#cb57-8" aria-hidden="true" tabindex="-1"></a>println<span class="op">(</span><span class="st">&quot;*s2=</span><span class="sc">{}</span><span class="st"> *s3=</span><span class="sc">{}</span><span class="st"> ainda existem!&quot;</span><span class="op">,</span> <span class="op">*</span>s2<span class="op">,</span> <span class="op">*</span>s3<span class="op">);</span></span></code></pre></div>
</section>
<section id="tipo-stdfunction-avançado" class="slide level2">
<h2>Tipo <code>std::function</code> (avançado)</h2>
<p>A estrutura <code>std::function&lt;tipo&gt;</code> permite armazenar
funções, seja ela uma lambda sem captura (<em>captureless lambda</em>)
ou uma lambda de captura, também chamada de <em>closure</em>. Uma
<em>captureless lambda</em> pode decair para ponteiro de função,
enquanto as demais só podem ser encapsuladas como
<code>std::function</code>. Basta fazer
<code>#include &lt;functional&gt;</code>. Exemplo:</p>
<div class="sourceCode" id="cb58"><pre
class="sourceCode .cpp"><code class="sourceCode cpp"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="co">// captureless lambda</span></span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span><span class="op">(*</span>fquad1<span class="op">)(</span><span class="dt">int</span><span class="op">)</span> <span class="op">=</span> <span class="op">[](</span><span class="dt">int</span> p<span class="op">)</span> <span class="op">-&gt;</span> <span class="dt">int</span> <span class="op">{</span> <span class="cf">return</span> p<span class="op">*</span>p<span class="op">;</span> <span class="op">};</span></span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>function<span class="op">&lt;</span><span class="dt">int</span><span class="op">(</span><span class="dt">int</span><span class="op">)&gt;</span> fquad2 <span class="op">=</span> <span class="op">[](</span><span class="dt">int</span> p<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> p<span class="op">*</span>p<span class="op">;</span> <span class="op">};</span></span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a><span class="co">// capturando variável x (por cópia)</span></span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> x <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> y <span class="op">=</span> <span class="dv">20</span><span class="op">;</span></span>
<span id="cb58-7"><a href="#cb58-7" aria-hidden="true" tabindex="-1"></a><span class="co">// closure x1 (retorna x + 1)</span></span>
<span id="cb58-8"><a href="#cb58-8" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>function<span class="op">&lt;</span><span class="dt">int</span><span class="op">()&gt;</span> x1 <span class="op">=</span> <span class="op">[</span>x<span class="op">]()</span> <span class="op">{</span> <span class="cf">return</span> x<span class="op">+</span><span class="dv">1</span><span class="op">;</span> <span class="op">};</span></span>
<span id="cb58-9"><a href="#cb58-9" aria-hidden="true" tabindex="-1"></a><span class="co">// capturando todas variáveis locais com =, y por referência</span></span>
<span id="cb58-10"><a href="#cb58-10" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>function<span class="op">&lt;</span><span class="dt">int</span><span class="op">()&gt;</span> fxy <span class="op">=</span> <span class="op">[=,</span> <span class="op">&amp;</span>y<span class="op">]()</span> <span class="op">{</span> y<span class="op">++;</span> <span class="cf">return</span> x<span class="op">+</span>y<span class="op">;</span> <span class="op">};</span></span>
<span id="cb58-11"><a href="#cb58-11" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> z <span class="op">=</span> fxy<span class="op">();</span> <span class="co">// z==31  y==21</span></span></code></pre></div>
</section>
<section id="proposta-para-um-stdscan-avançadoexperimental"
class="slide level2">
<h2>Proposta para um <code>std::scan</code> (avançado/experimental)</h2>
<p>Assim como o <code>std::print</code> (atualmente da
<code>fmt</code>), existem propostas para um <code>std::scan</code>,
atualmente no projeto <a
href="https://github.com/eliaskosunen/scnlib"><code>scnlib</code></a> de
<code>eliaskosunen</code>.</p>
<p>A proposta experimental para o C++26 se chama P1729 “Text Parsing”, e
busca criar uma função <code>scn::scan</code> que substitua a
<code>scanf</code> (pelo mesmo raciocínio empregado na abolição do
<code>printf</code>). Exemplo:</p>
<div class="sourceCode" id="cb59"><pre
class="sourceCode .cpp"><code class="sourceCode cpp"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;scn/scn.h&gt;</span></span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a><span class="co">// lembre-se de incluir o pacote eliaskosunen/scnlib no CMake</span></span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> scn<span class="op">::</span>scan<span class="op">;</span></span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a><span class="co">// ...</span></span>
<span id="cb59-5"><a href="#cb59-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> x <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb59-6"><a href="#cb59-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> y <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb59-7"><a href="#cb59-7" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> resto <span class="op">=</span> scan<span class="op">(</span><span class="st">&quot;10 20&quot;</span><span class="op">,</span> <span class="st">&quot;</span><span class="sc">{}</span><span class="st">&quot;</span><span class="op">,</span> x<span class="op">);</span></span>
<span id="cb59-8"><a href="#cb59-8" aria-hidden="true" tabindex="-1"></a>scan<span class="op">(</span>resto<span class="op">,</span> <span class="st">&quot;</span><span class="sc">{}</span><span class="st">&quot;</span><span class="op">,</span> y<span class="op">);</span></span>
<span id="cb59-9"><a href="#cb59-9" aria-hidden="true" tabindex="-1"></a>print<span class="op">(</span><span class="st">&quot;x=</span><span class="sc">{}</span><span class="st"> y=</span><span class="sc">{}</span><span class="st">&quot;</span><span class="op">,</span> x<span class="op">,</span> y<span class="op">);</span></span>
<span id="cb59-10"><a href="#cb59-10" aria-hidden="true" tabindex="-1"></a><span class="co">// x=10 y=20</span></span></code></pre></div>
</section>
<section id="ponteiro-cyclesrelation_ptr-avançadoexperimental"
class="slide level2">
<h2>Ponteiro <code>cycles::relation_ptr</code>
(avançado/experimental)</h2>
<p>Uma proposta de ponteiro inteligente para resolver casos cíclicos foi
criado pelo prof. Igor Machado Coelho, chamado <a
href="https://github.com/igormcoelho/cycles"><code>cycles::relation_ptr</code></a>.
Este é um projeto interessante para compreender as limitações dos
ponteiros inteligentes atuais, e o que pode ser possivelmente melhorado
em um C++ futuro. Exemplo:</p>
<p>Para utilizar, basta fazer
<code>#include &lt;cycles/relation_ptr&gt;</code>. Exemplo:</p>
<div class="sourceCode" id="cb60"><pre
class="sourceCode .cpp"><code class="sourceCode cpp"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> cycles<span class="op">::</span>relation_pool<span class="op">;</span></span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> cycles<span class="op">::</span>relation_ptr<span class="op">;</span></span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a><span class="co">// veja instruções em: https://github.com/igormcoelho/cycles</span></span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a>relation_pool<span class="op">&lt;&gt;</span> grupo<span class="op">;</span></span>
<span id="cb60-5"><a href="#cb60-5" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> r1 <span class="op">=</span> grupo<span class="op">.</span>make<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span><span class="dv">10</span><span class="op">);</span></span>
<span id="cb60-6"><a href="#cb60-6" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> r2 <span class="op">=</span> <span class="bu">std::</span>move<span class="op">(</span>r1<span class="op">);</span></span>
<span id="cb60-7"><a href="#cb60-7" aria-hidden="true" tabindex="-1"></a>print<span class="op">(</span><span class="st">&quot;*r2=</span><span class="sc">{}\n</span><span class="st">&quot;</span><span class="op">,*</span>r2<span class="op">);</span></span>
<span id="cb60-8"><a href="#cb60-8" aria-hidden="true" tabindex="-1"></a><span class="co">// *r2=10</span></span>
<span id="cb60-9"><a href="#cb60-9" aria-hidden="true" tabindex="-1"></a>r2<span class="op">.</span>reset<span class="op">();</span> <span class="co">// apaga ponteiro r2 manualmente</span></span></code></pre></div>
</section>
<section id="discussão-rápida-c-ou-c" class="slide level2">
<h2>Discussão Rápida: C ou C++?</h2>
<p>Citamos o comitê diretor do C++, <a
href="https://open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2000r4.pdf">“DIRECTION
FOR ISO C++” (2022-10-15), de H. Hinnant, R. Orr, B. Stroustrup, D.
Vandevoorde, M. Wong (página 10)</a>:</p>
<p><em>C++ is seriously underrepresented in academia and often very
poorly taught. It has been conventional to start teaching C++ by first
introducing the lowest level and most error-prone facilities. Naturally,
that discourages students and increases the time needed to get to what
students consider meaningful computing (graphics, networking,
mathematics, data analysis, etc.). Often, teachers even go to the
extreme of insisting on using a C compiler. If the ultimate aim is to
teach C++, that’s like insisting people start learning English by
reading Beowulf or the Canterbury Tales in their original early-English
language versions. Those are great books, but Early English is
incomprehensible to most native Modern-English speakers.</em></p>
</section>
<section id="discussão-rápida-c-ou-c-continuação" class="slide level2">
<h2>Discussão Rápida: C ou C++? (continuação)</h2>
<p>Citamos o comitê diretor do C++, <a
href="https://open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2000r4.pdf">“DIRECTION
FOR ISO C++” (2022-10-15), de H. Hinnant, R. Orr, B. Stroustrup, D.
Vandevoorde, M. Wong (página 10)</a>:</p>
<p><em>In addition to the linguistic difficulties, such ancient sources
present cultural conventions and idioms that seem very peculiar today.
Instead of C, someone could teach Simula to prepare for learning C++.
Why don’t people do that? Because the historical approach to teaching
language (natural or programming language) complicates and detracts from
the end goal: good code.</em></p>
<p><em>Why then do teachers use the C-first approach to teach C++? Part
is tradition, curriculum inertia, and ignorance, but part of the reason
is that C++ doesn’t offer a smooth path to idiomatic, proper, modern use
of C++. It is hard to bypass both the traps of low-level constructs and
the complexities of advanced features and teach programming and proper
C++ usage from the start.</em></p>
</section>
<section id="discussão-rápida-c-ou-c-resumo" class="slide level2">
<h2>Discussão Rápida: C ou C++? (resumo)</h2>
<p>Em resumo: C++ moderno já é absolutamente superior a C em segurança e
clareza, com desempenho equivalente, mas historicamente carece de boas
estruturas para fazer o <strong>básico</strong> (como imprimir em tela,
fazer vetores, etc), obrigando o uso de estruturas inseguras, como
ponteiros. Então, as revisões recentes tem buscado esse fim, de
facilitar o uso básico (como <code>std::print</code>,
<code>std::array</code>, <code>std::string</code>,
<code>std::vector</code>, smart pointers, …) e evitar que a linguagem C
seja necessária para a escrita de programas básicos.</p>
<p>Hoje (2023) ainda existem problemas, como:</p>
<ul>
<li>necessidade de usar bibliotecas externas (estamos precisando do
<code>fmt::print</code> e <code>scn::scan</code>)</li>
<li>necessidade de fazer <code>#include</code> em um código básico: a
ideia é que, a partir da implementação de <code>import std</code> no
C++23, será desnecessário incluir bibliotecas externas em códigos
básicos <code>:)</code></li>
</ul>
<p>Muitos serão resolvidos na próxima edição do C++ (mas ainda faltará o
<code>scn::scan</code>), sempre de olho em bons concorrentes modernos
como Rust.</p>
</section>
<section class="slide level2">

</section></section>
<section>
<section id="modularização-e-testes-a-revisar"
class="title-slide slide level1">
<h1>Modularização e Testes (a revisar!!)</h1>

</section>
<section id="motivação-modularização-e-testes" class="slide level2">
<h2>Motivação: Modularização e Testes</h2>
<p>Qualquer programa complexo necessita de divisão em partes, ou
módulos, para maior controle e verificação da corretude das
operações.</p>
<p>Nesse curso, vamos utilizar um padrão mínimo de modularização, para
que seja possível efetuar testes no código (de forma sistemática).</p>
</section>
<section id="modularização-básica" class="slide level2">
<h2>Modularização Básica</h2>
<p>Um programa começa pelo seu “ponto de entrada” (ou
<em>entrypoint</em>), tipicamente uma função
<code>int main()</code>:</p>
<div class="sourceCode" id="cb61"><pre
class="sourceCode .cpp"><code class="sourceCode cpp"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include</span><span class="im">&lt;iostream&gt;</span><span class="pp"> </span><span class="co">// inclui arquivo externo</span></span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a>   <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span>       <span class="co">// 0 significa: nenhum erro</span></span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>A declaração de funções pode ser feita antes da definição:</p>
<div class="sourceCode" id="cb62"><pre
class="sourceCode .cpp"><code class="sourceCode cpp"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> quadrado<span class="op">(</span><span class="dt">int</span> p<span class="op">);</span> <span class="co">// declara a função &#39;quadrado&#39;</span></span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> quadrado<span class="op">(</span><span class="dt">int</span> p<span class="op">)</span> <span class="op">{</span></span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a>   <span class="cf">return</span> p<span class="op">*</span>p<span class="op">;</span>       <span class="co">// implementa a função &#39;quadrado&#39;</span></span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Declarações vem em arquivos <code>.h</code>, enquanto as respectivas
implementações em arquivo <code>.cpp</code> (ou juntas como
<code>.hpp</code>).</p>
</section>
<section id="executando-o-main.cpp" class="slide level2">
<h2>Executando o <code>main.cpp</code></h2>
<p>Quando utilizando o GCC e um <em>entrypoint</em> no arquivo
<code>main.cpp</code>:</p>
<p><strong><em>Para compilar:</em></strong>
<code>g++ -fconcepts -O3 main.cpp -o appMain</code></p>
<p><strong><em>Para executar código:</em></strong>
<code>./appMain</code></p>
<p><strong>Importante:</strong> consideramos um sistema GNU/Linux, mas
caso seja Windows pode-se usar o compilador C/C++ <a
href="https://osdn.net/projects/mingw/releases">MinGW</a> e executar o
aplicativo gerado com uma extensão <code>.exe</code> (padrão executável
Windows).</p>
</section>
<section id="organização-em-arquivos-i" class="slide level2">
<h2>Organização em Arquivos I</h2>
<p>Modularização mínima: 4 arquivos.</p>
<ul>
<li>um ponto de entrada (entrypoint) - geralmente <code>main.cpp</code>
(dica: colocar na pasta <code>src/</code>)</li>
<li>um (ou mais) arquivo(s) com demais módulos (dica: colocar na pasta
<code>src/</code>)</li>
<li>um (ou mais) arquivo(s) com seus testes - geralmente
<code>teste.cpp</code> (dica: colocar na pasta <code>tests/</code>)</li>
<li>um arquivo (na raiz) com informações de construção - geralmente
<code>makefile</code> do GNU (com regras <code>all:</code> e
<code>test:</code>)</li>
</ul>
</section>
<section id="organização-em-arquivos-ii" class="slide level2">
<h2>Organização em Arquivos II</h2>
<p>Também é informativo um arquivo extra na raiz com explicações sobre o
código (tipicamente <code>README.md</code> na linguagem markdown)</p>
<p><strong>Importante:</strong> o arquivo do <em>entrypoint</em> deverá
conter exclusivamente a função <code>int main()</code> (e seus
respectivos <code>#include</code>), para viabilizar testes de
código.</p>
</section>
<section id="tipos-na-biblioteca-padrão-c" class="slide level2">
<h2>Tipos na biblioteca padrão C++</h2>
<p>Durante o curso estudaremos várias estruturas de dados, mas sempre
que possível utilize as existentes na biblioteca padrão (STL). São “mais
eficientes” e “à prova de erros”.</p>
<p>Por exemplo, é fácil definir um tipo agregado <code>Par</code>, que
comporta dois elementos internos (tipo genérico). Porém, é mais
vantajoso usar o existente na STL, chamado <code>std::pair</code> (o
prefixo <code>std::</code> é chamado <em>namespace</em> e evita colisões
de nomes):</p>
<div class="sourceCode" id="cb63"><pre
class="sourceCode .cpp"><code class="sourceCode cpp"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include</span><span class="im">&lt;iostream&gt;</span><span class="pp"> </span><span class="co">// funções de entrada/saída</span></span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include</span><span class="im">&lt;tuple&gt;</span><span class="pp">    </span><span class="co">// agregados de par e tupla</span></span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true" tabindex="-1"></a>   <span class="bu">std::</span>pair<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">char</span><span class="op">&gt;</span> p <span class="op">{</span><span class="dv">5</span><span class="op">,</span> <span class="ch">&#39;C&#39;</span><span class="op">};</span> <span class="co">// direct init.</span></span>
<span id="cb63-5"><a href="#cb63-5" aria-hidden="true" tabindex="-1"></a>   printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d</span><span class="st"> </span><span class="sc">%c\n</span><span class="st">&quot;</span><span class="op">,</span> p<span class="op">.</span>first<span class="op">,</span> p<span class="op">.</span>second<span class="op">);</span> <span class="co">// 5 C</span></span>
<span id="cb63-6"><a href="#cb63-6" aria-hidden="true" tabindex="-1"></a>   <span class="co">// ...</span></span>
<span id="cb63-7"><a href="#cb63-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</section>
<section id="relembrando-agregado-z" class="slide level2">
<h2>Relembrando (agregado Z)</h2>
<div class="sourceCode" id="cb64"><pre
class="sourceCode .cpp"><code class="sourceCode cpp"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Em C++ (tipo agregado Z)</span></span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Z</span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb64-5"><a href="#cb64-5" aria-hidden="true" tabindex="-1"></a>   <span class="dt">int</span> x<span class="op">;</span></span>
<span id="cb64-6"><a href="#cb64-6" aria-hidden="true" tabindex="-1"></a>   <span class="co">// imprime campo x</span></span>
<span id="cb64-7"><a href="#cb64-7" aria-hidden="true" tabindex="-1"></a>   <span class="dt">void</span> imprimex<span class="op">()</span> <span class="op">{</span></span>
<span id="cb64-8"><a href="#cb64-8" aria-hidden="true" tabindex="-1"></a>      printf<span class="op">(</span><span class="st">&quot;</span><span class="sc">%d\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="kw">this</span><span class="op">-&gt;</span>x<span class="op">);</span></span>
<span id="cb64-9"><a href="#cb64-9" aria-hidden="true" tabindex="-1"></a>   <span class="op">}</span></span>
<span id="cb64-10"><a href="#cb64-10" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
</section>
<section id="relembrando-conceito-temimprimex" class="slide level2">
<h2>Relembrando (conceito TemImprimeX)</h2>
<div class="sourceCode" id="cb65"><pre
class="sourceCode .cpp"><code class="sourceCode cpp"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> Agregado<span class="op">&gt;</span></span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a><span class="kw">concept</span> <span class="dt">bool</span></span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a>TemImprimeX <span class="op">=</span> <span class="kw">requires</span><span class="op">(</span>Agregado a<span class="op">)</span> <span class="op">{</span></span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true" tabindex="-1"></a>   <span class="op">{</span></span>
<span id="cb65-5"><a href="#cb65-5" aria-hidden="true" tabindex="-1"></a>      a<span class="op">.</span>imprimex<span class="op">()</span></span>
<span id="cb65-6"><a href="#cb65-6" aria-hidden="true" tabindex="-1"></a>   <span class="op">}</span></span>
<span id="cb65-7"><a href="#cb65-7" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
</section>
<section id="verificações-com-assert" class="slide level2">
<h2>Verificações com <code>assert</code></h2>
<p>Durante o desenvolvimento, é útil verificar partes do código com
testes simples e necessários para a corretude do mesmo (em tempo real).
Para isso, podemos utilizar o <code>assert()</code>. Exemplo:</p>
<div class="sourceCode" id="cb66"><pre
class="sourceCode .cpp"><code class="sourceCode cpp"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> x <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a>x<span class="op">++;</span></span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a><span class="ot">assert</span><span class="op">(</span>x <span class="op">==</span> <span class="dv">11</span><span class="op">);</span> <span class="co">// x deveria ser 11</span></span></code></pre></div>
<p>Da mesma forma, podemos verificar tipos, especialmente
<em>conceitos</em>, em tempo de compilação:</p>
<div class="sourceCode" id="cb67"><pre
class="sourceCode .cpp"><code class="sourceCode cpp"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="co">// verifica se tipo agregado Z tem método imprimex()</span></span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a><span class="kw">static_assert</span><span class="op">(</span>TemImprimeX<span class="op">&lt;</span>Z<span class="op">&gt;);</span> </span></code></pre></div>
</section>
<section id="testes-com-a-biblioteca-catch2" class="slide level2">
<h2>Testes com a biblioteca Catch2</h2>
<p>Uma forma prática de testar um código modularizado com
<code>main.cpp</code> separado do <code>resto.hpp</code>, é utilizando a
biblioteca <a href="https://github.com/catchorg/Catch2">Catch2</a>.</p>
<p>Basta criar um arquivo de teste, por exemplo,
<code>teste.cpp</code>:</p>
<div class="sourceCode" id="cb68"><pre
class="sourceCode .cpp"><code class="sourceCode cpp"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;resto.hpp&quot;</span></span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#define CATCH_CONFIG_MAIN </span><span class="co">// catch2 main()</span></span>
<span id="cb68-4"><a href="#cb68-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;catch.hpp&quot;</span></span>
<span id="cb68-5"><a href="#cb68-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-6"><a href="#cb68-6" aria-hidden="true" tabindex="-1"></a>TEST_CASE<span class="op">(</span><span class="st">&quot;Testa inicializacao do agregado Z&quot;</span><span class="op">)</span> </span>
<span id="cb68-7"><a href="#cb68-7" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb68-8"><a href="#cb68-8" aria-hidden="true" tabindex="-1"></a>   <span class="kw">auto</span> z1 <span class="op">=</span> Z<span class="op">{.</span>x <span class="op">=</span> <span class="dv">10</span><span class="op">};</span></span>
<span id="cb68-9"><a href="#cb68-9" aria-hidden="true" tabindex="-1"></a>   <span class="co">// verifica se, de fato, z1.x vale 10</span></span>
<span id="cb68-10"><a href="#cb68-10" aria-hidden="true" tabindex="-1"></a>   REQUIRE<span class="op">(</span>z1<span class="op">.</span>x <span class="op">==</span> <span class="dv">10</span><span class="op">);</span></span>
<span id="cb68-11"><a href="#cb68-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</section>
<section id="baixando-o-catch2-e-executando" class="slide level2">
<h2>Baixando o Catch2 e executando</h2>
<p>Para baixar o arquivo <code>catch2.hpp</code>, basta acessar o site
do projeto: <a
href="https://github.com/catchorg/Catch2">github.com/catchorg/Catch2</a>.
Link direto (Agosto 2020):</p>
<p><em>github.com/catchorg/Catch2/releases/download/v2.13.1/catch.hpp</em></p>
<p><strong><em>Para compilar:</em></strong>
<code>g++ -fconcepts teste.cpp -o appTestes</code></p>
<p><strong><em>Para executar testes:</em></strong>
<code>./appTestes -d yes</code></p>
<pre><code>0.000 s: Testa inicializacao do agregado Z
===============================================
All tests passed (1 assertion in 1 test case)</code></pre>
<p><strong>Importante:</strong> Recomenda-se a opção
<code>-fsanitize=address</code> e <code>-g3</code> para evitar bugs
durante o desenvolvimento usando GCC.</p>
</section>
<section id="continue-aprendendo" class="slide level2">
<h2>Continue Aprendendo</h2>
<p>Nessa revisão sobre tipos, buscamos não aprofundar em nenhuma
característica “avançada” de C/C++, embora alguns conceitos possam
parecer novos. Tópicos recomendados (não cobertos no curso):</p>
<ul>
<li>Orientação a Objetos (outras disciplinas cobrem esse tópico)</li>
<li>uso frequente de <em>referências</em> (ao invés de ponteiros)</li>
<li>uso frequente de <em>move semantics</em> (ao invés de
referências)</li>
<li>uso frequente de <em>closures</em> (ao invés de funções e
lambdas)</li>
<li>uso frequente de memórias auto-gerenciáveis, como
<code>std::unique_ptr</code> e <code>std::shared_ptr</code> (não requer
<code>delete</code>)</li>
<li>uso de <em>corrotinas</em> do C++20 (somente consideramos
<em>rotinas</em> no curso), especialmente para elaboração de iteradores
infinitos</li>
<li>teste de microbenchmarks (recomendamos a biblioteca <a
href="https://github.com/google/benchmark">Google Benchmark</a>)</li>
</ul>
</section>
<section id="bibliografia-recomendada" class="slide level2">
<h2>Bibliografia Recomendada</h2>
<p>Além da bibliografia do curso, recomendamos (para esse tópico):</p>
<ul>
<li>Livro “Introdução a estruturas de dados” de W. Celes e J. L.
Rangel</li>
<li>Livro “The C++ Programming Language” de Bjarne Stroustrup</li>
<li>Dicas e normas C++: https://github.com/isocpp/CppCoreGuidelines</li>
</ul>
</section></section>
<section>
<section id="agradecimentos" class="title-slide slide level1">
<h1>Agradecimentos</h1>

</section>
<section id="pessoas" class="slide level2">
<h2>Pessoas</h2>
<p>Em especial, agradeço aos colegas que elaboraram bons materiais, como
o prof. Fabiano Oliveira (IME-UERJ), e o prof. Jayme Szwarcfiter cujos
conceitos formam o cerne desses slides.</p>
<p>Estendo os agradecimentos aos demais colegas que colaboraram com a
elaboração do material do curso de <a
href="https://github.com/igormcoelho/curso-pesquisa-operacional-i">Pesquisa
Operacional</a>, que abriu caminho para verificação prática dessa
tecnologia de slides.</p>
</section>
<section id="software" class="slide level2">
<h2>Software</h2>
<p>Esse material de curso só é possível graças aos inúmeros projetos de
código-aberto que são necessários a ele, incluindo:</p>
<ul>
<li>pandoc</li>
<li>LaTeX</li>
<li>GNU/Linux</li>
<li>git</li>
<li>markdown-preview-enhanced (github)</li>
<li>visual studio code</li>
<li>atom</li>
<li>revealjs</li>
<li>groomit-mpx (screen drawing tool)</li>
<li>xournal (screen drawing tool)</li>
<li>…</li>
</ul>
</section>
<section id="empresas" class="slide level2">
<h2>Empresas</h2>
<p>Agradecimento especial a empresas que suportam projetos livres
envolvidos nesse curso:</p>
<ul>
<li>github</li>
<li>gitlab</li>
<li>microsoft</li>
<li>google</li>
<li>…</li>
</ul>
</section>
<section id="reprodução-do-material" class="slide level2">
<h2>Reprodução do material</h2>
<p>Esses slides foram escritos utilizando pandoc, segundo o tutorial
ilectures:</p>
<ul>
<li>https://igormcoelho.github.io/ilectures-pandoc/</li>
</ul>
<p>Exceto expressamente mencionado (com as devidas ressalvas ao material
cedido por colegas), a licença será Creative Commons.</p>
<p><strong>Licença:</strong> CC-BY 4.0 2020</p>
<p>Igor Machado Coelho</p>
</section>
<section id="this-slide-is-intentionally-blank-for-goomit-mpx"
class="slide level2">
<h2>This Slide Is Intentionally Blank (for goomit-mpx)</h2>
</section></section>
    </div>
  </div>

  <script src="./reveal.js/dist/reveal.js"></script>

  <!-- reveal.js plugins -->
  <script src="./reveal.js/plugin/notes/notes.js"></script>
  <script src="./reveal.js/plugin/search/search.js"></script>
  <script src="./reveal.js/plugin/zoom/zoom.js"></script>

  <script>

      // Full list of configuration options available at:
      // https://revealjs.com/config/
      Reveal.initialize({
        // Display controls in the bottom right corner
        controls: true,

        // Help the user learn the controls by providing hints, for example by
        // bouncing the down arrow when they first encounter a vertical slide
        controlsTutorial: true,

        // Determines where controls appear, "edges" or "bottom-right"
        controlsLayout: 'bottom-right',

        // Visibility rule for backwards navigation arrows; "faded", "hidden"
        // or "visible"
        controlsBackArrows: 'faded',

        // Display a presentation progress bar
        progress: true,

        // Display the page number of the current slide
        slideNumber: false,

        // 'all', 'print', or 'speaker'
        showSlideNumber: 'all',

        // Add the current slide number to the URL hash so that reloading the
        // page/copying the URL will return you to the same slide
        hash: true,

        // Start with 1 for the hash rather than 0
        hashOneBasedIndex: false,

        // Flags if we should monitor the hash and change slides accordingly
        respondToHashChanges: true,

        // Push each slide change to the browser history
        history: false,

        // Enable keyboard shortcuts for navigation
        keyboard: true,

        // Enable the slide overview mode
        overview: true,

        // Disables the default reveal.js slide layout (scaling and centering)
        // so that you can use custom CSS layout
        disableLayout: false,

        // Vertical centering of slides
        center: true,

        // Enables touch navigation on devices with touch input
        touch: true,

        // Loop the presentation
        loop: false,

        // Change the presentation direction to be RTL
        rtl: false,

        // see https://revealjs.com/vertical-slides/#navigation-mode
        navigationMode: 'default',

        // Randomizes the order of slides each time the presentation loads
        shuffle: false,

        // Turns fragments on and off globally
        fragments: true,

        // Flags whether to include the current fragment in the URL,
        // so that reloading brings you to the same fragment position
        fragmentInURL: true,

        // Flags if the presentation is running in an embedded mode,
        // i.e. contained within a limited portion of the screen
        embedded: false,

        // Flags if we should show a help overlay when the questionmark
        // key is pressed
        help: true,

        // Flags if it should be possible to pause the presentation (blackout)
        pause: true,

        // Flags if speaker notes should be visible to all viewers
        showNotes: false,

        // Global override for autoplaying embedded media (null/true/false)
        autoPlayMedia: null,

        // Global override for preloading lazy-loaded iframes (null/true/false)
        preloadIframes: null,

        // Number of milliseconds between automatically proceeding to the
        // next slide, disabled when set to 0, this value can be overwritten
        // by using a data-autoslide attribute on your slides
        autoSlide: 0,

        // Stop auto-sliding after user input
        autoSlideStoppable: true,

        // Use this method for navigation when auto-sliding
        autoSlideMethod: null,

        // Specify the average time in seconds that you think you will spend
        // presenting each slide. This is used to show a pacing timer in the
        // speaker view
        defaultTiming: null,

        // Enable slide navigation via mouse wheel
        mouseWheel: false,

        // The display mode that will be used to show slides
        display: 'block',

        // Hide cursor if inactive
        hideInactiveCursor: true,

        // Time before the cursor is hidden (in ms)
        hideCursorTime: 5000,

        // Opens links in an iframe preview overlay
        previewLinks: false,

        // Transition style (none/fade/slide/convex/concave/zoom)
        transition: 'linear',

        // Transition speed (default/fast/slow)
        transitionSpeed: 'default',

        // Transition style for full page slide backgrounds
        // (none/fade/slide/convex/concave/zoom)
        backgroundTransition: 'fade',

        // Number of slides away from the current that are visible
        viewDistance: 3,

        // Number of slides away from the current that are visible on mobile
        // devices. It is advisable to set this to a lower number than
        // viewDistance in order to save resources.
        mobileViewDistance: 2,

        // reveal.js plugins
        plugins: [
          RevealNotes,
          RevealSearch,
          RevealZoom
        ]
      });
    </script>
    </body>
</html>
